ca65 V2.19 - Git d36800591
Main file   : sxb-hacker.asm
Current file: sxb-hacker.asm

000000r 1               ;===============================================================================
000000r 1               ;  ______  ______        _   _            _
000000r 1               ; / ___\ \/ / __ )      | | | | __ _  ___| | _____ _ __
000000r 1               ; \___ \\  /|  _ \ _____| |_| |/ _` |/ __| |/ / _ \ '__|
000000r 1               ;  ___) /  \| |_) |_____|  _  | (_| | (__|   <  __/ |
000000r 1               ; |____/_/\_\____/      |_| |_|\__,_|\___|_|\_\___|_|
000000r 1               ;
000000r 1               ; A program for Hacking your W65C265SXB or W65C816SXB
000000r 1               ;-------------------------------------------------------------------------------
000000r 1               ; Copyright (C),2015-2018 Andrew Jacobs
000000r 1               ; All rights reserved.
000000r 1               ;
000000r 1               ; CC65 conversion by Derek Mulcahy.
000000r 1               ;
000000r 1               ; This work is made available under the terms of the Creative Commons
000000r 1               ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
000000r 1               ; following URL to see the details.
000000r 1               ;
000000r 1               ; http://creativecommons.org/licenses/by-nc-sa/4.0/
000000r 1               ;
000000r 1               ;===============================================================================
000000r 1               ; Notes:
000000r 1               ;
000000r 1               ; This program provides a simple monitor that you can use to inspect the memory
000000r 1               ; in your SXB and reprogram parts of the flash ROM.
000000r 1               ;
000000r 1               ;-------------------------------------------------------------------------------
000000r 1               
000000r 1                               .list on
000000r 1                               .p816
000000r 1               
000000r 1                               .include "w65c816.inc"
000000r 2               ;==============================================================================
000000r 2               ; __        ____  ____   ____ ___  _  __
000000r 2               ; \ \      / / /_| ___| / ___( _ )/ |/ /_
000000r 2               ;  \ \ /\ / / '_ \___ \| |   / _ \| | '_ \
000000r 2               ;   \ V  V /| (_) |__) | |__| (_) | | (_) |
000000r 2               ;    \_/\_/  \___/____/ \____\___/|_|\___/
000000r 2               ;
000000r 2               ; Western Design Center W65C816 device definitions
000000r 2               ;------------------------------------------------------------------------------
000000r 2               ; Copyright (C)2015 HandCoded Software Ltd.
000000r 2               ; All rights reserved.
000000r 2               ;
000000r 2               ; This work is made available under the terms of the Creative Commons
000000r 2               ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
000000r 2               ; following URL to see the details.
000000r 2               ;
000000r 2               ; http://creativecommons.org/licenses/by-nc-sa/4.0/
000000r 2               ;
000000r 2               ;===============================================================================
000000r 2               ; Notes:
000000r 2               ;
000000r 2               ; Various macros and definitions for the W65C816 microprocessor.
000000r 2               ;
000000r 2               ;===============================================================================
000000r 2               ; Revision History:
000000r 2               ;
000000r 2               ; 2015-12-18 AJ Initial version
000000r 2               ;-------------------------------------------------------------------------------
000000r 2               ; $Id$
000000r 2               ;-------------------------------------------------------------------------------
000000r 2               
000000r 2               ;==============================================================================
000000r 2               ; Status Register Bits
000000r 2               ;------------------------------------------------------------------------------
000000r 2               
000000r 2               N_FLAG          =     1<<7
000000r 2               V_FLAG          =     1<<6
000000r 2               M_FLAG          =     1<<5
000000r 2               X_FLAG          =     1<<4
000000r 2               B_FLAG          =     1<<4
000000r 2               D_FLAG          =     1<<3
000000r 2               I_FLAG          =     1<<2
000000r 2               Z_FLAG          =     1<<1
000000r 2               C_FLAG          =     1<<0
000000r 2               
000000r 2               ;==============================================================================
000000r 2               ; Macros
000000r 2               ;------------------------------------------------------------------------------
000000r 2               
000000r 2               ; Puts the processor in emulation mode. A, X and Y become 8-bits and the stack
000000r 2               ; is fixed at $0100-$01ff.
000000r 2               
000000r 2               .macro          emulate
000000r 2                               sec
000000r 2                               xce
000000r 2               .endmacro
000000r 2               
000000r 2               ; Puts the processor in native mode. The size of the memory and index register
000000r 2               ; operations is not controlled by the M & X bits in the status register.
000000r 2               
000000r 2               .macro          native
000000r 2                               clc
000000r 2                               xce
000000r 2               .endmacro
000000r 2               
000000r 2               ; Resets the M bit making the accumulator and memory accesses 16-bits wide.
000000r 2               
000000r 2               .macro          long_a
000000r 2                               rep     #M_FLAG
000000r 2                               .a16
000000r 2               .endmacro
000000r 2               
000000r 2               ; Resets the X bit making the index registers 16-bits wide
000000r 2               
000000r 2               .macro          long_i
000000r 2                               rep     #X_FLAG
000000r 2                               .i16
000000r 2               .endmacro
000000r 2               
000000r 2               ; Resets the M and X bits making the accumulator, memory accesses and index
000000r 2               ; registers 16-bits wide.
000000r 2               
000000r 2               .macro          long_ai
000000r 2                               rep     #M_FLAG|X_FLAG
000000r 2                               .a16
000000r 2                               .i16
000000r 2               .endmacro
000000r 2               
000000r 2               ; Sets the M bit making the accumulator and memory accesses 8-bits wide.
000000r 2               
000000r 2               .macro          short_a
000000r 2                               sep     #M_FLAG
000000r 2                               .a8
000000r 2               .endmacro
000000r 2               
000000r 2               ; Sets the X bit making the index registers 8-bits wide.
000000r 2               
000000r 2               .macro          short_i
000000r 2                               sep     #X_FLAG
000000r 2                               .i8
000000r 2               .endmacro
000000r 2               
000000r 2               ; Sets the M & X bits making the accumulator, memory accesses and index
000000r 2               ; registers 8-bits wide.
000000r 2               
000000r 2               .macro          short_ai
000000r 2                               sep     #M_FLAG|X_FLAG
000000r 2                               .a8
000000r 2                               .i8
000000r 2               .endmacro
000000r 2               
000000r 1               
000000r 1               ;===============================================================================
000000r 1               ;-------------------------------------------------------------------------------
000000r 1               
000000r 1               .macro          MNEM  P,Q,R
000000r 1                               .word     ((((P-'@')<<5)|(Q-'@'))<<5)|(R-'@')
000000r 1               .endmacro
000000r 1               
000000r 1               ;===============================================================================
000000r 1               ; ASCII Character Codes
000000r 1               ;-------------------------------------------------------------------------------
000000r 1               
000000r 1               SOH             =     $01
000000r 1               EOT             =     $04
000000r 1               ACK             =     $06
000000r 1               BEL             =     $07
000000r 1               BS              =     $08
000000r 1               LF              =     $0a
000000r 1               CR              =     $0d
000000r 1               NAK             =     $15
000000r 1               CAN             =     $18
000000r 1               ESC             =     $1b
000000r 1               DEL             =     $7f
000000r 1               
000000r 1               ;===============================================================================
000000r 1               ;-------------------------------------------------------------------------------
000000r 1               
000000r 1               OP_ADC          =     0<<1
000000r 1               OP_AND          =     1<<1
000000r 1               OP_ASL          =     2<<1
000000r 1               OP_BCC          =     3<<1
000000r 1               OP_BCS          =     4<<1
000000r 1               OP_BEQ          =     5<<1
000000r 1               OP_BIT          =     6<<1
000000r 1               OP_BMI          =     7<<1
000000r 1               OP_BNE          =     8<<1
000000r 1               OP_BPL          =     9<<1
000000r 1               OP_BRA          =     10<<1
000000r 1               OP_BRK          =     11<<1
000000r 1               OP_BRL          =     12<<1
000000r 1               OP_BVC          =     13<<1
000000r 1               OP_BVS          =     14<<1
000000r 1               OP_CLC          =     15<<1
000000r 1               OP_CLD          =     16<<1
000000r 1               OP_CLI          =     17<<1
000000r 1               OP_CLV          =     18<<1
000000r 1               OP_CMP          =     19<<1
000000r 1               OP_COP          =     20<<1
000000r 1               OP_CPX          =     21<<1
000000r 1               OP_CPY          =     22<<1
000000r 1               OP_DEC          =     23<<1
000000r 1               OP_DEX          =     24<<1
000000r 1               OP_DEY          =     25<<1
000000r 1               OP_EOR          =     26<<1
000000r 1               OP_INC          =     27<<1
000000r 1               OP_INX          =     28<<1
000000r 1               OP_INY          =     29<<1
000000r 1               OP_JML          =     30<<1
000000r 1               OP_JMP          =     31<<1
000000r 1               OP_JSL          =     32<<1
000000r 1               OP_JSR          =     33<<1
000000r 1               OP_LDA          =     34<<1
000000r 1               OP_LDX          =     35<<1
000000r 1               OP_LDY          =     36<<1
000000r 1               OP_LSR          =     37<<1
000000r 1               OP_MVN          =     38<<1
000000r 1               OP_MVP          =     39<<1
000000r 1               OP_NOP          =     40<<1
000000r 1               OP_ORA          =     41<<1
000000r 1               OP_PEA          =     42<<1
000000r 1               OP_PEI          =     43<<1
000000r 1               OP_PER          =     44<<1
000000r 1               OP_PHA          =     45<<1
000000r 1               OP_PHB          =     46<<1
000000r 1               OP_PHD          =     47<<1
000000r 1               OP_PHK          =     48<<1
000000r 1               OP_PHP          =     49<<1
000000r 1               OP_PHX          =     50<<1
000000r 1               OP_PHY          =     51<<1
000000r 1               OP_PLA          =     52<<1
000000r 1               OP_PLB          =     53<<1
000000r 1               OP_PLD          =     54<<1
000000r 1               OP_PLP          =     55<<1
000000r 1               OP_PLX          =     56<<1
000000r 1               OP_PLY          =     57<<1
000000r 1               OP_REP          =     58<<1
000000r 1               OP_ROL          =     59<<1
000000r 1               OP_ROR          =     60<<1
000000r 1               OP_RTI          =     61<<1
000000r 1               OP_RTL          =     62<<1
000000r 1               OP_RTS          =     63<<1
000000r 1               OP_SBC          =     64<<1
000000r 1               OP_SEC          =     65<<1
000000r 1               OP_SED          =     66<<1
000000r 1               OP_SEI          =     67<<1
000000r 1               OP_SEP          =     68<<1
000000r 1               OP_STA          =     69<<1
000000r 1               OP_STP          =     70<<1
000000r 1               OP_STX          =     71<<1
000000r 1               OP_STY          =     72<<1
000000r 1               OP_STZ          =     73<<1
000000r 1               OP_TAX          =     74<<1
000000r 1               OP_TAY          =     75<<1
000000r 1               OP_TCD          =     76<<1
000000r 1               OP_TCS          =     77<<1
000000r 1               OP_TDC          =     78<<1
000000r 1               OP_TRB          =     79<<1
000000r 1               OP_TSB          =     80<<1
000000r 1               OP_TSC          =     81<<1
000000r 1               OP_TSX          =     82<<1
000000r 1               OP_TXA          =     83<<1
000000r 1               OP_TXS          =     84<<1
000000r 1               OP_TXY          =     85<<1
000000r 1               OP_TYA          =     86<<1
000000r 1               OP_TYX          =     87<<1
000000r 1               OP_WAI          =     88<<1
000000r 1               OP_WDM          =     89<<1
000000r 1               OP_XBA          =     90<<1
000000r 1               OP_XCE          =     91<<1
000000r 1               
000000r 1               MD_ABS          =     0<<1                    ; a
000000r 1               MD_ACC          =     1<<1                    ; A
000000r 1               MD_ABX          =     2<<1                    ; a,x
000000r 1               MD_ABY          =     3<<1                    ; a,y
000000r 1               MD_ALG          =     4<<1                    ; al
000000r 1               MD_ALX          =     5<<1                    ; al,x
000000r 1               MD_AIN          =     6<<1                    ; (a)
000000r 1               MD_AIX          =     7<<1                    ; (a,x)
000000r 1               MD_DPG          =     8<<1                    ; d
000000r 1               MD_STK          =     9<<1                    ; d,s
000000r 1               MD_DPX          =     10<<1                   ; d,x
000000r 1               MD_DPY          =     11<<1                   ; d,x
000000r 1               MD_DIN          =     12<<1                   ; (d)
000000r 1               MD_DLI          =     13<<1                   ; [d]
000000r 1               MD_SKY          =     14<<1                   ; (d,s),y
000000r 1               MD_DIX          =     15<<1                   ; (d,x)
000000r 1               MD_DIY          =     16<<1                   ; (d),y
000000r 1               MD_DLY          =     17<<1                   ; [d],y
000000r 1               MD_IMP          =     18<<1                   ;
000000r 1               MD_REL          =     19<<1                   ; r
000000r 1               MD_RLG          =     20<<1                   ; rl
000000r 1               MD_MOV          =     21<<1                   ; xyc
000000r 1               MD_IMM          =     22<<1                   ; # (A or M)
000000r 1               MD_INT          =     23<<1                   ; # (BRK/COP/WDM)
000000r 1               MD_IMX          =     24<<1                   ; # (X or Y)
000000r 1               
000000r 1               ;===============================================================================
000000r 1               ; Data Areas
000000r 1               ;-------------------------------------------------------------------------------
000000r 1               
000000r 1                                .segment "ZEROPAGE"
000000r 1               
000000r 1                                .org     $20
000020  1               
000020  1  xx           FLAGS:           .res      1                       ; Emulated processor flags
000021  1  xx           BUFLEN:          .res      1                       ; Command buffer length
000022  1  xx           BANK:            .res      1                       ; Memory bank
000023  1               
000023  1  xx xx xx     ADDR_S:          .res      3                       ; Start address
000026  1  xx xx xx     ADDR_E:          .res      3                       ; End address
000029  1               
000029  1  xx           BLOCK:           .res      1                       ; XMODEM block number
00002A  1  xx           RETRIES:         .res      1                       ; Retry count
00002B  1  xx           SUM:             .res      1                       ; Checksum
00002C  1               
00002C  1  xx xx xx xx  TEMP:            .res      4                       ; Scratch workspace
000030  1               
000030  1                                .segment "BSS"
000030  1               
000030  1                                .org      $0200
000200  1               
000200  1  xx xx xx xx  BUFFER:          .res      256                     ; Command buffer
000204  1  xx xx xx xx  
000208  1  xx xx xx xx  
000300  1               
000300  1               ;===============================================================================
000300  1               ; Initialisation
000300  1               ;-------------------------------------------------------------------------------
000300  1               
000300  1                               .segment "CODE"
000300  1               
000300  1                               .org $039b
00039B  1               
00039B  1                               .export  Start
00039B  1                               .import  UartRx
00039B  1                               .import  UartTx
00039B  1                               .import  UartRxTest
00039B  1                               .import  RomSelect
00039B  1                               .import  RomCheck
00039B  1               Start:
00039B  1  E2 20                        short_a                         ; Configure register sizes
00039D  1  C2 10                        long_i
00039F  1  20 1D 09                     jsr     TxCRLF
0003A2  1  A2 2E 0E                     ldx     #TITLE                  ; Display application title
0003A5  1  20 11 09                     jsr     TxStr
0003A8  1               
0003A8  1  64 22                        stz     BANK                    ; Reset default bank
0003AA  1               
0003AA  1               ;===============================================================================
0003AA  1               ; Command Processor
0003AA  1               ;-------------------------------------------------------------------------------
0003AA  1               
0003AA  1               NewCommand:
0003AA  1  64 21                        stz     BUFLEN                  ; Clear the buffer
0003AC  1               ShowCommand:
0003AC  1  E2 10                        short_i
0003AE  1  20 1D 09                     jsr     TxCRLF                  ; Move to a new line
0003B1  1               
0003B1  1  A9 2E                        lda     #'.'                    ; Output the prompt
0003B3  1  20 rr rr                     jsr     UartTx
0003B6  1               
0003B6  1  A2 00                        ldx     #0
0003B8  1  E4 21        DisplayCmd:     cpx     BUFLEN                  ; Any saved characters
0003BA  1  F0 0E                        beq     ReadCommand
0003BC  1  BD 00 02                     lda     BUFFER,x                ; Yes, display them
0003BF  1  20 rr rr                     jsr     UartTx
0003C2  1  E8                           inx
0003C3  1  80 F3                        bra     DisplayCmd
0003C5  1               
0003C5  1               RingBell:
0003C5  1  A9 07                        lda     #BEL                    ; Make a beep
0003C7  1  20 rr rr                     jsr     UartTx
0003CA  1               
0003CA  1               ReadCommand:
0003CA  1  20 rr rr                     jsr     UartRx                  ; Wait for character
0003CD  1               
0003CD  1  C9 1B                        cmp     #ESC                    ; Cancel input?
0003CF  1  F0 D9                        beq     NewCommand              ; Yes, clear and restart
0003D1  1  C9 0D                        cmp     #CR                     ; End of command?
0003D3  1  F0 2D                        beq     ProcessCommand          ; Yes, start processing
0003D5  1               
0003D5  1  C9 08                        cmp     #BS                     ; Back space?
0003D7  1  F0 15                        beq     BackSpace
0003D9  1  C9 7F                        cmp     #DEL                    ; Delete?
0003DB  1  F0 11                        beq     BackSpace
0003DD  1               
0003DD  1  C9 20                        cmp     #' '                    ; Printable character
0003DF  1  90 E4                        bcc     RingBell                ; No.
0003E1  1  C9 7F                        cmp     #DEL
0003E3  1  B0 E0                        bcs     RingBell                ; No.
0003E5  1  9D 00 02                     sta     BUFFER,x                ; Save the character
0003E8  1  E8                           inx
0003E9  1  20 rr rr                     jsr     UartTx                  ; Echo it and repeat
0003EC  1  80 DC                        bra     ReadCommand
0003EE  1               
0003EE  1               BackSpace:
0003EE  1  E0 00                        cpx     #0                      ; Buffer empty?
0003F0  1  F0 D3                        beq     RingBell                ; Yes, beep and continue
0003F2  1  CA                           dex                             ; No, remove last character
0003F3  1  A9 08                        lda     #BS
0003F5  1  20 rr rr                     jsr     UartTx
0003F8  1  20 2A 09                     jsr     TxSpace
0003FB  1  A9 08                        lda     #BS
0003FD  1  20 rr rr                     jsr     UartTx
000400  1  80 C8                        bra     ReadCommand             ; And retry
000402  1               
000402  1               ProcessCommand:
000402  1  86 21                        stx     BUFLEN                  ; Save final length
000404  1  A0 00                        ldy     #0                      ; Load index for start
000406  1               
000406  1  20 9F 08                     jsr     SkipSpaces              ; Fetch command character
000409  1  B0 9F                        bcs     NewCommand              ; None, empty command
00040B  1               
00040B  1               ;===============================================================================
00040B  1               ; B - Select Memory Bank
00040B  1               ;-------------------------------------------------------------------------------
00040B  1               
00040B  1  C9 42                        cmp     #'B'                    ; Select memory bank?
00040D  1  D0 0D                        bne     NotMemoryBank
00040F  1               
00040F  1  A2 22                        ldx     #BANK                   ; Parse bank
000411  1  20 05 08                     jsr     GetByte
000414  1  90 03                        bcc     *+5
000416  1  4C E7 07                     jmp     ShowError
000419  1  4C AA 03                     jmp     NewCommand
00041C  1               NotMemoryBank:
00041C  1               
00041C  1               ;===============================================================================
00041C  1               ; D - Disassemble Memory
00041C  1               ;-------------------------------------------------------------------------------
00041C  1               
00041C  1  C9 44                        cmp     #'D'                    ; Memory display?
00041E  1  D0 78                        bne     NotDisassemble
000420  1               
000420  1  A2 23                        ldx     #ADDR_S                 ; Parse start address
000422  1  20 27 08                     jsr     GetAddr
000425  1  90 03                        bcc     *+5
000427  1  4C E7 07                     jmp     ShowError
00042A  1  A2 26                        ldx     #ADDR_E                 ; Parse end address
00042C  1  20 27 08                     jsr     GetAddr
00042F  1  90 03                        bcc     *+5
000431  1  4C E7 07                     jmp     ShowError
000434  1               
000434  1  08                           php
000435  1  68                           pla
000436  1  85 20                        sta     FLAGS
000438  1               
000438  1               Disassemble:
000438  1  20 1D 09                     jsr     TxCRLF
00043B  1  A5 25                        lda     ADDR_S+2                ; Show memory address
00043D  1  20 F8 08                     jsr     TxHex2
000440  1  A9 3A                        lda     #':'
000442  1  20 rr rr                     jsr     UartTx
000445  1  A5 24                        lda     ADDR_S+1
000447  1  20 F8 08                     jsr     TxHex2
00044A  1  A5 23                        lda     ADDR_S+0
00044C  1  20 F8 08                     jsr     TxHex2
00044F  1  20 2A 09                     jsr     TxSpace
000452  1               
000452  1  20 2F 09                     jsr     TxCodeBytes             ; Show code bytes
000455  1  20 54 09                     jsr     TxSymbolic              ; And instruction
000458  1               
000458  1  A7 23                        lda     [ADDR_S]                ; Fetch opcode again
00045A  1  48                           pha
00045B  1  A0 01                        ldy     #1
00045D  1               
00045D  1  C9 18                        cmp     #$18                    ; CLC?
00045F  1  D0 04                        bne     NotCLC
000461  1  A9 01                        lda     #C_FLAG
000463  1  80 0E                        bra     DoREP
000465  1               NotCLC:
000465  1  C9 38                        cmp     #$38                    ; SEC?
000467  1  D0 04                        bne     NotSEC
000469  1  A9 01                        lda     #C_FLAG
00046B  1  80 10                        bra     DoSEP
00046D  1               NotSEC:
00046D  1  C9 C2                        cmp     #$c2                    ; REP?
00046F  1  D0 06                        bne     NotREP
000471  1  B7 23                        lda     [ADDR_S],Y
000473  1  14 20        DoREP:          trb     FLAGS
000475  1  80 08                        bra     NextOpcode
000477  1               NotREP:
000477  1  C9 E2                        cmp     #$e2                    ; SEP?
000479  1  D0 04                        bne     NextOpcode
00047B  1  B7 23                        lda     [ADDR_S],Y
00047D  1  04 20        DoSEP:          tsb     FLAGS
00047F  1               
00047F  1               NextOpcode:
00047F  1  68                           pla
000480  1  20 20 0B                     jsr     OpcodeSize
000483  1               
000483  1  18                           clc
000484  1  65 23                        adc     ADDR_S+0                ; And move start address on
000486  1  85 23                        sta     ADDR_S+0
000488  1  90 02                        bcc     *+4
00048A  1  E6 24                        inc     ADDR_S+1
00048C  1               
00048C  1  38                           sec                             ; Exceeded the end address?
00048D  1  E5 26                        sbc     ADDR_E+0
00048F  1  A5 24                        lda     ADDR_S+1
000491  1  E5 27                        sbc     ADDR_E+1
000493  1  30 A3                        bmi     Disassemble             ; No, show more
000495  1               
000495  1  4C AA 03                     jmp     NewCommand              ; Done
000498  1               NotDisassemble:
000498  1               
000498  1               ;===============================================================================
000498  1               ; E - Erase ROM bank
000498  1               ;-------------------------------------------------------------------------------
000498  1               
000498  1  C9 45                        cmp     #'E'                    ; Erase bank?
00049A  1  D0 45                        bne     NotEraseBank
00049C  1               
00049C  1  20 F2 07                     jsr     CheckSafe
00049F  1               
00049F  1                               .ifdef   W65C265SXB
00049F  1                               lda     BCR                     ; Save mask rom state
00049F  1                               pha
00049F  1                               lda     #$80                    ; Then ensure disabled
00049F  1                               tsb     BCR
00049F  1                               .endif
00049F  1               
00049F  1  A9 00                        lda     #$00                    ; Set start address
0004A1  1  85 23                        sta     ADDR_S+0
0004A3  1  A9 80                        lda     #$80
0004A5  1  85 24                        sta     ADDR_S+1
0004A7  1               EraseLoop:
0004A7  1  A9 AA                        lda     #$aa                    ; Unlock flash
0004A9  1  8D 55 D5                     sta     $8000+$5555
0004AC  1  A9 55                        lda     #$55
0004AE  1  8D AA AA                     sta     $8000+$2aaa
0004B1  1  A9 80                        lda     #$80                    ; Signal erase
0004B3  1  8D 55 D5                     sta     $8000+$5555
0004B6  1  A9 AA                        lda     #$aa
0004B8  1  8D 55 D5                     sta     $8000+$5555
0004BB  1  A9 55                        lda     #$55
0004BD  1  8D AA AA                     sta     $8000+$2aaa
0004C0  1  A9 30                        lda     #$30                    ; Sector erase
0004C2  1  92 23                        sta     (ADDR_S)
0004C4  1               
0004C4  1               EraseWait:
0004C4  1  B2 23                        lda     (ADDR_S)                ; Wait for erase to finish
0004C6  1  C9 FF                        cmp     #$FF
0004C8  1  D0 FA                        bne     EraseWait
0004CA  1               
0004CA  1  18                           clc                             ; Move to next sector
0004CB  1  A5 24                        lda     ADDR_S+1
0004CD  1  69 10                        adc     #$10
0004CF  1  85 24                        sta     ADDR_S+1
0004D1  1  90 D4                        bcc     EraseLoop               ; Repeat until end of memory
0004D3  1               
0004D3  1                               .ifdef   W65C265SXB
0004D3  1                               pla                             ; Restore mask ROM state
0004D3  1                               sta     BCR
0004D3  1                               .endif
0004D3  1               
0004D3  1  4C AA 03                     jmp     NewCommand              ; And start over
0004D6  1               
0004D6  1               EraseFailed:
0004D6  1  C2 10                        long_i                          ; Warn that erase failed
0004D8  1  A2 64 0E                     ldx     #ERASE_FAILED
0004DB  1  20 11 09                     jsr     TxStr
0004DE  1                               .i8
0004DE  1  4C AA 03                     jmp     NewCommand              ; And start over
0004E1  1               NotEraseBank:
0004E1  1               
0004E1  1               ;===============================================================================
0004E1  1               ; F - WDC Mask ROM Enable/Disable
0004E1  1               ;-------------------------------------------------------------------------------
0004E1  1               
0004E1  1                               .ifdef   W65C265SXB
0004E1  1                               cmp     #'F'
0004E1  1                               bne     NotMaskROM
0004E1  1               
0004E1  1                               jsr     SkipSpaces              ; Find first argument
0004E1  1                               bcs     MaskFail                ; Success?
0004E1  1               
0004E1  1                               cmp     #'0'                    ; Check bank is 0..3
0004E1  1                               beq     MaskOff
0004E1  1                               cmp     #'1'
0004E1  1                               beq     MaskOn
0004E1  1               MaskFail:
0004E1  1                               jmp     ShowError
0004E1  1               
0004E1  1               MaskOn:
0004E1  1                               lda     #$80                    ; Enable mask ROM
0004E1  1                               trb     BCR
0004E1  1                               jmp     NewCommand
0004E1  1               
0004E1  1               MaskOff:
0004E1  1                               lda     #$80                    ; Disable mask ROM
0004E1  1                               tsb     BCR
0004E1  1                               jmp     NewCommand
0004E1  1               
0004E1  1               NotMaskROM:
0004E1  1                               .endif
0004E1  1               
0004E1  1               ;===============================================================================
0004E1  1               ; G - Goto
0004E1  1               ;-------------------------------------------------------------------------------
0004E1  1               
0004E1  1  C9 47                        cmp     #'G'                    ; Invoke code
0004E3  1  D0 0D                        bne     NotGoto
0004E5  1               
0004E5  1  A2 23                        ldx     #ADDR_S                 ; Parse execution address
0004E7  1  20 27 08                     jsr     GetAddr
0004EA  1  B0 03                        bcs     *+5
0004EC  1  DC 23 00                     jmp     [ADDR_S]                ; Run from address
0004EF  1  6C FC FF                     jmp     ($FFFC)                 ; Otherwise reset
0004F2  1               NotGoto:
0004F2  1               
0004F2  1               ;===============================================================================
0004F2  1               ; H - Hunt for RAM
0004F2  1               ;-------------------------------------------------------------------------------
0004F2  1               
0004F2  1  C9 48                        cmp     #'H'                    ; Hunt for RAM
0004F4  1  F0 03                        beq     *+5
0004F6  1  4C 8B 05                     jmp     NotHunt
0004F9  1               
0004F9  1  64 23                        stz     ADDR_S+0                ; Start at $00:0000
0004FB  1  64 24                        stz     ADDR_S+1
0004FD  1  64 25                        stz     ADDR_S+2
0004FF  1               
0004FF  1               HuntStart:
0004FF  1  A7 23                        lda     [ADDR_S]                ; Is byte is writeable?
000501  1  48                           pha
000502  1  49 FF                        eor     #$ff
000504  1  87 23                        sta     [ADDR_S]
000506  1  C7 23                        cmp     [ADDR_S]
000508  1  F0 11                        beq     HuntFound               ; Yes
00050A  1               
00050A  1  68                           pla
00050B  1  18                           clc                             ; Try the next block
00050C  1  A5 24                        lda     ADDR_S+1
00050E  1  69 10                        adc     #$10
000510  1  85 24                        sta     ADDR_S+1
000512  1  90 EB                        bcc     HuntStart
000514  1  E6 25                        inc     ADDR_S+2
000516  1  D0 E7                        bne     HuntStart
000518  1  4C AA 03                     jmp     NewCommand              ; Reached end of RAM
00051B  1               
00051B  1               HuntFound:
00051B  1  20 1D 09                     jsr     TxCRLF
00051E  1  A5 25                        lda     ADDR_S+2                ; Print start address
000520  1  20 F8 08                     jsr     TxHex2
000523  1  A9 3A                        lda     #':'
000525  1  20 rr rr                     jsr     UartTx
000528  1  A5 24                        lda     ADDR_S+1
00052A  1  20 F8 08                     jsr     TxHex2
00052D  1  A5 23                        lda     ADDR_S+0
00052F  1  20 F8 08                     jsr     TxHex2
000532  1               
000532  1  A9 2D                        lda     #'-'
000534  1  20 rr rr                     jsr     UartTx
000537  1               
000537  1               HuntEnd:
000537  1  68                           pla                             ; Restore memory bytes
000538  1  87 23                        sta     [ADDR_S]
00053A  1  18                           clc                             ; Try the next block
00053B  1  A5 24                        lda     ADDR_S+1
00053D  1  69 10                        adc     #$10
00053F  1  85 24                        sta     ADDR_S+1
000541  1  90 04                        bcc     HuntNext
000543  1  E6 25                        inc     ADDR_S+2
000545  1  F0 2D                        beq     HuntDone
000547  1               
000547  1               HuntNext:
000547  1  A7 23                        lda     [ADDR_S]                ; Is byte is writeable?
000549  1  48                           pha
00054A  1  49 FF                        eor     #$ff
00054C  1  87 23                        sta     [ADDR_S]
00054E  1  C7 23                        cmp     [ADDR_S]
000550  1  F0 E5                        beq     HuntEnd                 ; Yes, keep looking
000552  1               
000552  1  68                           pla
000553  1  38                           sec                             ; Print end address
000554  1  A5 23                        lda     ADDR_S+0
000556  1  E9 01                        sbc     #1
000558  1  48                           pha
000559  1  A5 24                        lda     ADDR_S+1
00055B  1  E9 00                        sbc     #0
00055D  1  48                           pha
00055E  1  A5 25                        lda     ADDR_S+2
000560  1  E9 00                        sbc     #0
000562  1  20 F8 08                     jsr     TxHex2
000565  1  A9 3A                        lda     #':'
000567  1  20 rr rr                     jsr     UartTx
00056A  1  68                           pla
00056B  1  20 F8 08                     jsr     TxHex2
00056E  1  68                           pla
00056F  1  20 F8 08                     jsr     TxHex2
000572  1  80 8B                        bra     HuntStart
000574  1               
000574  1               HuntDone:
000574  1  A9 FF                        lda     #$ff                    ; Pring FF:FFFF
000576  1  48                           pha
000577  1  48                           pha
000578  1  20 F8 08                     jsr     TxHex2
00057B  1  A9 3A                        lda     #':'
00057D  1  20 rr rr                     jsr     UartTx
000580  1  68                           pla
000581  1  20 F8 08                     jsr     TxHex2
000584  1  68                           pla
000585  1  20 F8 08                     jsr     TxHex2
000588  1  4C AA 03                     jmp     NewCommand
00058B  1               NotHunt:
00058B  1               
00058B  1               ;===============================================================================
00058B  1               ; M - Display Memory
00058B  1               ;-------------------------------------------------------------------------------
00058B  1               
00058B  1  C9 4D                        cmp     #'M'                    ; Memory display?
00058D  1  D0 70                        bne     NotMemoryDisplay
00058F  1               
00058F  1  A2 23                        ldx     #ADDR_S                 ; Parse start address
000591  1  20 27 08                     jsr     GetAddr
000594  1  90 03                        bcc     *+5
000596  1  4C E7 07                     jmp     ShowError
000599  1  A2 26                        ldx     #ADDR_E                 ; Parse end address
00059B  1  20 27 08                     jsr     GetAddr
00059E  1  90 03                        bcc     *+5
0005A0  1  4C E7 07                     jmp     ShowError
0005A3  1               
0005A3  1               DisplayMemory:
0005A3  1  20 1D 09                     jsr     TxCRLF
0005A6  1  A5 25                        lda     ADDR_S+2                ; Show memory address
0005A8  1  20 F8 08                     jsr     TxHex2
0005AB  1  A9 3A                        lda     #':'
0005AD  1  20 rr rr                     jsr     UartTx
0005B0  1  A5 24                        lda     ADDR_S+1
0005B2  1  20 F8 08                     jsr     TxHex2
0005B5  1  A5 23                        lda     ADDR_S+0
0005B7  1  20 F8 08                     jsr     TxHex2
0005BA  1               
0005BA  1  A0 00                        ldy     #0                      ; Show sixteen bytes of data
0005BC  1  20 2A 09     ByteLoop:       jsr     TxSpace
0005BF  1  B7 23                        lda     [ADDR_S],y
0005C1  1  20 F8 08                     jsr     TxHex2
0005C4  1  C8                           iny
0005C5  1  C0 10                        cpy     #16
0005C7  1  D0 F3                        bne     ByteLoop
0005C9  1               
0005C9  1  20 2A 09                     jsr     TxSpace
0005CC  1  A9 7C                        lda     #'|'
0005CE  1  20 rr rr                     jsr     UartTx
0005D1  1  A0 00                        ldy     #0                      ; Show sixteen characters
0005D3  1  B7 23        CharLoop:       lda     [ADDR_S],Y
0005D5  1  20 EE 08                     jsr     IsPrintable
0005D8  1  B0 02                        bcs     *+4
0005DA  1  A9 2E                        lda     #'.'
0005DC  1  20 rr rr                     jsr     UartTx
0005DF  1  C8                           iny
0005E0  1  C0 10                        cpy     #16
0005E2  1  D0 EF                        bne     CharLoop
0005E4  1  A9 7C                        lda     #'|'
0005E6  1  20 rr rr                     jsr     UartTx
0005E9  1               
0005E9  1  18                           clc                             ; Bump the display address
0005EA  1  98                           tya
0005EB  1  65 23                        adc     ADDR_S+0
0005ED  1  85 23                        sta     ADDR_S+0
0005EF  1  90 02                        bcc     *+4
0005F1  1  E6 24                        inc     ADDR_S+1
0005F3  1               
0005F3  1  38                           sec                             ; Exceeded the end address?
0005F4  1  E5 26                        sbc     ADDR_E+0
0005F6  1  A5 24                        lda     ADDR_S+1
0005F8  1  E5 27                        sbc     ADDR_E+1
0005FA  1  30 A7                        bmi     DisplayMemory           ; No, show more
0005FC  1               
0005FC  1  4C AA 03                     jmp     NewCommand
0005FF  1               NotMemoryDisplay:
0005FF  1               
0005FF  1               ;===============================================================================
0005FF  1               ; R - Select ROM Bank
0005FF  1               ;-------------------------------------------------------------------------------
0005FF  1               
0005FF  1  C9 52                        cmp     #'R'                    ; ROM Bank?
000601  1  D0 16                        bne     NotROMBank              ; No
000603  1               
000603  1  20 9F 08                     jsr     SkipSpaces              ; Find first argument
000606  1  90 03                        bcc     *+5                     ; Success?
000608  1  4C E7 07     BankFail:       jmp     ShowError               ; No
00060B  1               
00060B  1  C9 30                        cmp     #'0'                    ; Check bank is 0..3
00060D  1  90 F9                        bcc     BankFail
00060F  1  C9 34                        cmp     #'3'+1
000611  1  B0 F5                        bcs     BankFail
000613  1               
000613  1  20 rr rr                     jsr     RomSelect               ; Switch ROM banks
000616  1  4C AA 03                     jmp     NewCommand              ; Done
000619  1               NotROMBank:
000619  1               
000619  1               ;===============================================================================
000619  1               ; S - S19 Record
000619  1               ;-------------------------------------------------------------------------------
000619  1               
000619  1  C9 53                        cmp     #'S'                    ; S19?
00061B  1  F0 03                        beq     *+5
00061D  1  4C A5 06                     jmp     NotS19
000620  1               
000620  1  20 93 08                     jsr     NextChar                ; Get record type
000623  1  B0 75                        bcs     S19Fail
000625  1  C9 31                        cmp     #'1'                    ; Only process type 1
000627  1  D0 6E                        bne     S19Done
000629  1               
000629  1  A2 26                        ldx     #ADDR_E                 ; Get byte count
00062B  1  20 05 08                     jsr     GetByte
00062E  1  B0 6A                        bcs     S19Fail
000630  1  A5 26                        lda     ADDR_E                  ; Use as initial checksum
000632  1  85 2B                        sta     SUM
000634  1  C6 26                        dec     ADDR_E                  ; REMOVE!!!
000636  1                               ; Byte count not included in the S19 byte count field
000636  1  F0 62                        beq     S19Fail
000638  1               
000638  1  A2 23                        ldx     #ADDR_S                 ; Get address
00063A  1  20 27 08                     jsr     GetAddr
00063D  1  B0 5B                        bcs     S19Fail
00063F  1  A5 23                        lda     ADDR_S+0                ; Add to checksum
000641  1  65 24                        adc     ADDR_S+1
000643  1  18                           clc
000644  1  65 2B                        adc     SUM
000646  1  85 2B                        sta     SUM
000648  1  C6 26                        dec     ADDR_E
00064A  1  F0 4E                        beq     S19Fail
00064C  1  C6 26                        dec     ADDR_E
00064E  1  F0 4A                        beq     S19Fail
000650  1               
000650  1               S19Load:
000650  1  A2 2C                        ldx     #TEMP                   ; Fetch a data byte
000652  1  20 05 08                     jsr     GetByte
000655  1  B0 43                        bcs     S19Fail
000657  1  A5 2C                        lda     TEMP
000659  1  65 2B                        adc     SUM
00065B  1  85 2B                        sta     SUM
00065D  1  C6 26                        dec     ADDR_E
00065F  1  F0 39                        beq     S19Fail
000661  1               
000661  1  A5 25                        lda     ADDR_S+2                ; Writing to ROM?
000663  1  D0 13                        bne     WriteS19                ; No
000665  1  A5 24                        lda     ADDR_S+1
000667  1  10 0F                        bpl     WriteS19                ; No
000669  1               
000669  1                               .ifdef   W65C265SXB
000669  1                               cmp     #$df                    ; Register page?
000669  1                               beq     NoWrite
000669  1                               .endif
000669  1               
000669  1  A9 AA                        lda     #$aa                    ; Yes, unlock flash
00066B  1  8D 55 D5                     sta     $8000+$5555
00066E  1  A9 55                        lda     #$55
000670  1  8D AA AA                     sta     $8000+$2aaa
000673  1  A9 A0                        lda     #$a0                    ; Start byte write
000675  1  8D 55 D5                     sta     $8000+$5555
000678  1               WriteS19:
000678  1  A5 2C                        lda     TEMP                    ; Write the value
00067A  1  87 23                        sta     [ADDR_S]
00067C  1               
00067C  1               NoWrite:
00067C  1  E6 23                        inc     ADDR_S+0                ; Bump address by one
00067E  1  D0 02                        bne     *+4
000680  1  E6 24                        inc     ADDR_S+1
000682  1               
000682  1  A5 26                        lda     ADDR_E                  ; Reached checksum?
000684  1  C9 01                        cmp     #1
000686  1  D0 C8                        bne     S19Load
000688  1               
000688  1  A2 2C                        ldx     #TEMP                   ; Yes, read it
00068A  1  20 05 08                     jsr     GetByte
00068D  1  B0 0B                        bcs     S19Fail
00068F  1  A5 2C                        lda     TEMP
000691  1  65 2B                        adc     SUM
000693  1  C9 FF                        cmp     #$ff                    ; Checksum correct?
000695  1  D0 03                        bne     S19Fail
000697  1               
000697  1  4C AA 03     S19Done:        jmp     NewCommand              ; Get
00069A  1               
00069A  1               S19Fail:
00069A  1  C2 10                        long_i                          ; Display error message
00069C  1  A2 9A 0E                     ldx     #INVALID_S19
00069F  1  20 11 09                     jsr     TxStr
0006A2  1                               .i8
0006A2  1  4C AA 03                     jmp     NewCommand              ; And start over
0006A5  1               NotS19:
0006A5  1               
0006A5  1               ;===============================================================================
0006A5  1               ; W - Write memory
0006A5  1               ;-------------------------------------------------------------------------------
0006A5  1               
0006A5  1  C9 57                        cmp     #'W'                    ; Write memory?
0006A7  1  D0 58                        bne     NotWrite
0006A9  1               
0006A9  1  A2 23                        ldx     #ADDR_S                 ; Parse start address
0006AB  1  20 27 08                     jsr     GetAddr
0006AE  1  90 03                        bcc     *+5
0006B0  1  4C E7 07                     jmp     ShowError
0006B3  1               
0006B3  1  24 24                        bit     ADDR_S+1                ; Load into ROM area?
0006B5  1  10 03                        bpl     *+5
0006B7  1  20 F2 07                     jsr     CheckSafe               ; Yes, check selection
0006BA  1               
0006BA  1  A2 26                        ldx     #ADDR_E                 ; Parse value byte
0006BC  1  20 05 08                     jsr     GetByte                 ; Is there a value?
0006BF  1  90 03                        bcc     *+5
0006C1  1  4C AA 03                     jmp     NewCommand              ; No.
0006C4  1               
0006C4  1  A5 25                        lda     ADDR_S+2                ; Writing to ROM?
0006C6  1  D0 13                        bne     WriteMemory             ; No
0006C8  1  24 24                        bit     ADDR_S+1
0006CA  1  10 0F                        bpl     WriteMemory             ; No
0006CC  1               
0006CC  1  A9 AA                        lda     #$aa                    ; Yes, unlock flash
0006CE  1  8D 55 D5                     sta     $8000+$5555
0006D1  1  A9 55                        lda     #$55
0006D3  1  8D AA AA                     sta     $8000+$2aaa
0006D6  1  A9 A0                        lda     #$a0                    ; Start byte write
0006D8  1  8D 55 D5                     sta     $8000+$5555
0006DB  1               WriteMemory:
0006DB  1  A5 26                        lda     ADDR_E                  ; Write the value
0006DD  1  87 23                        sta     [ADDR_S]
0006DF  1               
0006DF  1  E6 23                        inc     ADDR_S+0                ; Bump address by one
0006E1  1  D0 02                        bne     *+4
0006E3  1  E6 24                        inc     ADDR_S+1
0006E5  1               
0006E5  1  A9 57                        lda     #'W'                    ; Build command for next byte
0006E7  1  20 AB 08                     jsr     StartCommand
0006EA  1  A9 20                        lda     #' '
0006EC  1  20 AD 08                     jsr     BuildCommand
0006EF  1  A5 24                        lda     ADDR_S+1                ; Add the next address
0006F1  1  20 B5 08                     jsr     BuildByte
0006F4  1  A5 23                        lda     ADDR_S+0
0006F6  1  20 B5 08                     jsr     BuildByte
0006F9  1  A9 20                        lda     #' '
0006FB  1  20 AD 08                     jsr     BuildCommand
0006FE  1  4C AC 03                     jmp     ShowCommand             ; And prompt for data
000701  1               
000701  1               NotWrite:
000701  1               
000701  1               ;===============================================================================
000701  1               ; X - XMODEM Receive
000701  1               ;-------------------------------------------------------------------------------
000701  1               
000701  1  C9 58                        cmp     #'X'                    ; XModem upload?
000703  1  F0 03                        beq     *+5                     ; Yes.
000705  1  4C D8 07                     jmp     NotXModem
000708  1               
000708  1  A2 23                        ldx     #ADDR_S                 ; Parse start address
00070A  1  20 27 08                     jsr     GetAddr
00070D  1  90 03                        bcc     *+5
00070F  1  4C E7 07                     jmp     ShowError
000712  1               
000712  1  24 24                        bit     ADDR_S+1                ; Load into ROM area?
000714  1  10 03                        bpl     *+5
000716  1  20 F2 07                     jsr     CheckSafe               ; Yes, check selection
000719  1               
000719  1  C2 10                        long_i                          ; Display waiting message
00071B  1  A2 AF 0E                     ldx     #WAITING
00071E  1  20 11 09                     jsr     TxStr
000721  1  20 1D 09                     jsr     TxCRLF
000724  1  E2 10                        short_i
000726  1  64 29                        stz     BLOCK                   ; Reset the block number
000728  1  E6 29                        inc     BLOCK
00072A  1               
00072A  1               ResetRetries:
00072A  1  A9 0A                        lda     #10                     ; Reset the retry counter
00072C  1  85 2A                        sta     RETRIES
00072E  1               
00072E  1               TransferWait:
00072E  1  64 2C                        stz     TEMP+0                  ; Clear timeout counter
000730  1  64 2D                        stz     TEMP+1
000732  1  A9 EC                        lda     #.lobyte(-20)
000734  1  85 2E                        sta     TEMP+2
000736  1               TransferPoll:
000736  1  20 rr rr                     jsr     UartRxTest              ; Any data yet?
000739  1  B0 20                        bcs     TransferScan
00073B  1  E6 2C                        inc     TEMP+0
00073D  1  D0 F7                        bne     TransferPoll
00073F  1  E6 2D                        inc     TEMP+1
000741  1  D0 F3                        bne     TransferPoll
000743  1  E6 2E                        inc     TEMP+2
000745  1  D0 EF                        bne     TransferPoll
000747  1  C6 2A                        dec     RETRIES
000749  1  F0 05                        beq     TimedOut
00074B  1  20 D3 07                     jsr     SendNAK                 ; Send a NAK
00074E  1  80 DE                        bra     TransferWait
000750  1               
000750  1               TimedOut:
000750  1  C2 10                        long_i
000752  1  A2 D6 0E                     ldx     #TIMEOUT
000755  1  20 11 09                     jsr     TxStr
000758  1                               .i8
000758  1  4C AA 03                     jmp     NewCommand
00075B  1               
00075B  1               TransferScan:
00075B  1  20 rr rr                     jsr     UartRx                  ; Wait for SOH or EOT
00075E  1  C9 04                        cmp     #EOT
000760  1  F0 66                        beq     TransferDone
000762  1  C9 01                        cmp     #SOH
000764  1  D0 C8                        bne     TransferWait
000766  1  20 rr rr                     jsr     UartRx                  ; Check the block number
000769  1  C5 29                        cmp     BLOCK
00076B  1  D0 55                        bne     TransferError
00076D  1  20 rr rr                     jsr     UartRx                  ; Check inverted block
000770  1  49 FF                        eor     #$ff
000772  1  C5 29                        cmp     BLOCK
000774  1  D0 4C                        bne     TransferError
000776  1               
000776  1  A0 00                        ldy     #0
000778  1  84 2B                        sty     SUM                     ; Clear the check sum
00077A  1               TransferBlock:
00077A  1  20 rr rr                     jsr     UartRx
00077D  1  48                           pha
00077E  1               
00077E  1  A5 25                        lda     ADDR_S+2                ; Writing to ROM?
000780  1  D0 13                        bne     WriteByte               ; No
000782  1  A5 24                        lda     ADDR_S+1
000784  1  10 0F                        bpl     WriteByte               ; No
000786  1               
000786  1                               .ifdef   W65C265SXB
000786  1                               cmp     #$df                    ; Register page?
000786  1                               beq     WriteSkip
000786  1                               .endif
000786  1               
000786  1  A9 AA                        lda     #$aa                    ; Yes, unlock flash
000788  1  8D 55 D5                     sta     $8000+$5555
00078B  1  A9 55                        lda     #$55
00078D  1  8D AA AA                     sta     $8000+$2aaa
000790  1  A9 A0                        lda     #$a0                    ; Start byte write
000792  1  8D 55 D5                     sta     $8000+$5555
000795  1               
000795  1               WriteByte:
000795  1  68                           pla
000796  1  97 23                        sta     [ADDR_S],Y
000798  1               
000798  1               WriteWait:
000798  1  D7 23                        cmp     [ADDR_S],Y              ; Wait for write
00079A  1  D0 FC                        bne     WriteWait
00079C  1  80 01                        bra     *+3
00079E  1               
00079E  1               WriteSkip:
00079E  1  68                           pla
00079F  1               
00079F  1  18                           clc                             ; Add to check sum
0007A0  1  65 2B                        adc     SUM
0007A2  1  85 2B                        sta     SUM
0007A4  1  C8                           iny
0007A5  1  C0 80                        cpy     #128
0007A7  1  D0 D1                        bne     TransferBlock
0007A9  1  20 rr rr                     jsr     UartRx                  ; Check the check sum
0007AC  1  C5 2B                        cmp     SUM
0007AE  1  D0 12                        bne     TransferError           ; Failed
0007B0  1  18                           clc
0007B1  1  98                           tya
0007B2  1  65 23                        adc     ADDR_S+0                ; Bump address one block
0007B4  1  85 23                        sta     ADDR_S+0
0007B6  1  90 02                        bcc     *+4
0007B8  1  E6 24                        inc     ADDR_S+1
0007BA  1               
0007BA  1  20 CE 07                     jsr     SendACK                 ; Acknowledge block
0007BD  1  E6 29                        inc     BLOCK                   ; Bump block number
0007BF  1  4C 2E 07                     jmp     TransferWait
0007C2  1               
0007C2  1               TransferError:
0007C2  1  20 D3 07                     jsr     SendNAK                 ; Send a NAK
0007C5  1  4C 2E 07                     jmp     TransferWait            ; And try again
0007C8  1               
0007C8  1               TransferDone:
0007C8  1  20 CE 07                     jsr     SendACK                 ; Acknowledge transmission
0007CB  1  4C AA 03                     jmp     NewCommand              ; Done
0007CE  1               
0007CE  1               SendACK:
0007CE  1  A9 06                        lda     #ACK
0007D0  1  4C rr rr                     jmp     UartTx
0007D3  1               
0007D3  1               SendNAK:
0007D3  1  A9 15                        lda     #NAK
0007D5  1  4C rr rr                     jmp     UartTx
0007D8  1               
0007D8  1               NotXModem:
0007D8  1               
0007D8  1               ;===============================================================================
0007D8  1               ; ? - Help
0007D8  1               ;-------------------------------------------------------------------------------
0007D8  1               
0007D8  1  C9 3F                        cmp     #'?'                    ; Help command?
0007DA  1  D0 0B                        bne     NotHelp
0007DC  1               
0007DC  1  C2 10                        long_i
0007DE  1  A2 E0 0E                     ldx     #HELP                   ; Output help string
0007E1  1  20 11 09                     jsr     TxStr
0007E4  1                               .i8
0007E4  1  4C AA 03                     jmp     NewCommand
0007E7  1               NotHelp:
0007E7  1               
0007E7  1               ;-------------------------------------------------------------------------------
0007E7  1               
0007E7  1               ShowError:
0007E7  1  C2 10                        long_i
0007E9  1  A2 4A 0E                     ldx     #ERROR                  ; Output error message
0007EC  1  20 11 09                     jsr     TxStr
0007EF  1                               .i8
0007EF  1  4C AA 03                     jmp     NewCommand
0007F2  1               
0007F2  1               ;===============================================================================
0007F2  1               ;-------------------------------------------------------------------------------
0007F2  1               
0007F2  1               ; Checks if an expendable ROM bank is currently selected. If the bank with the
0007F2  1               ; WDC firmware is selected then warn and accept a new command.
0007F2  1               
0007F2  1               CheckSafe:
0007F2  1  20 rr rr                     jsr     RomCheck                ; WDC ROM selected?
0007F5  1  F0 01                        beq     *+3
0007F7  1  60                           rts                             ; No, save to change
0007F8  1               
0007F8  1  68                           pla                             ; Discard return address
0007F9  1  68                           pla
0007FA  1  C2 10                        long_i                          ; Complain about bank
0007FC  1  A2 82 0E                     ldx     #NOT_SAFE
0007FF  1  20 11 09                     jsr     TxStr
000802  1                               .i8
000802  1  4C AA 03                     jmp     NewCommand              ; And start over
000805  1               
000805  1               ;===============================================================================
000805  1               ; Byte and Word Parsing
000805  1               ;-------------------------------------------------------------------------------
000805  1               
000805  1               ; Parse a hex byte from the command line and store it at the location indicated
000805  1               ; by the X register.
000805  1               
000805  1               GetByte:
000805  1  9E 00 00                     stz     a:0,x                   ; REMOVE a: Set the target address
000808  1  20 9F 08                     jsr     SkipSpaces              ; Skip to first real character
00080B  1  90 01                        bcc     *+3
00080D  1  60                           rts                             ; None found
00080E  1  20 DC 08                     jsr     IsHexDigit              ; Must have at least one digit
000811  1  90 12                        bcc     ByteFail
000813  1  20 6B 08                     jsr     AddDigit
000816  1  20 93 08                     jsr     NextChar
000819  1  B0 08                        bcs     ByteDone
00081B  1  20 DC 08                     jsr     IsHexDigit
00081E  1  90 03                        bcc     ByteDone
000820  1  20 6B 08                     jsr     AddDigit
000823  1  18           ByteDone:       clc
000824  1  60                           rts
000825  1  38           ByteFail:       sec
000826  1  60                           rts
000827  1               
000827  1               ; Parse an address from the command line and store it at the location indicated
000827  1               ; by the X register.
000827  1               
000827  1               GetAddr:
000827  1  9E 00 00                     stz     a:0,x                   ; REMOVE a: Set the target address
00082A  1  9E 01 00                     stz     a:1,x                   ; REMOVE a:
00082D  1  A5 22                        lda     BANK
00082F  1  9D 02 00                     sta     a:2,x                   ; REMOVE a:
000832  1  20 9F 08                     jsr     SkipSpaces              ; Skip to first real character
000835  1  90 01                        bcc     *+3
000837  1  60                           rts                             ; None found
000838  1               
000838  1  20 DC 08                     jsr     IsHexDigit              ; Must have at least one digit
00083B  1  90 2C                        bcc     AddrFail
00083D  1  20 6B 08                     jsr     AddDigit
000840  1  20 93 08                     jsr     NextChar
000843  1  B0 22                        bcs     AddrDone
000845  1  20 DC 08                     jsr     IsHexDigit
000848  1  90 1D                        bcc     AddrDone
00084A  1  20 6B 08                     jsr     AddDigit
00084D  1  20 93 08                     jsr     NextChar
000850  1  B0 15                        bcs     AddrDone
000852  1  20 DC 08                     jsr     IsHexDigit
000855  1  90 10                        bcc     AddrDone
000857  1  20 6B 08                     jsr     AddDigit
00085A  1  20 93 08                     jsr     NextChar
00085D  1  B0 08                        bcs     AddrDone
00085F  1  20 DC 08                     jsr     IsHexDigit
000862  1  90 03                        bcc     AddrDone
000864  1  20 6B 08                     jsr     AddDigit
000867  1  18           AddrDone:       clc                             ; Carry clear got an address
000868  1  60                           rts
000869  1  38           AddrFail:       sec                             ; Carry set -- failed.
00086A  1  60                           rts
00086B  1               
00086B  1               ; Add a hex digit to the 16-bit value being build at at the location indicated
00086B  1               ; by X.
00086B  1               
00086B  1               AddDigit:
00086B  1  38                           sec                             ; Convert ASCII to binary
00086C  1  E9 30                        sbc     #'0'
00086E  1  C9 0A                        cmp     #$0a
000870  1  90 02                        bcc     *+4
000872  1  E9 07                        sbc     #7
000874  1               
000874  1  1E 00 00                     asl     a:0,x                     ; Shift up one nybble
000877  1  3E 01 00                     rol     a:1,x
00087A  1  1E 00 00                     asl     a:0,x
00087D  1  3E 01 00                     rol     a:1,x
000880  1  1E 00 00                     asl     a:0,x
000883  1  3E 01 00                     rol     a:1,x
000886  1  1E 00 00                     asl     a:0,x
000889  1  3E 01 00                     rol     a:1,x
00088C  1               
00088C  1  1D 00 00                     ora     a:0,x                     ; Merge in new digit
00088F  1  9D 00 00                     sta     a:0,x                     ; .. and save
000892  1  60                           rts
000893  1               
000893  1               ;===============================================================================
000893  1               ; Command Line Parsing and Building
000893  1               ;-------------------------------------------------------------------------------
000893  1               
000893  1               ; Get the next character from the command buffer updating the position in X.
000893  1               ; Set the carry if the end of the buffer is reached.
000893  1               
000893  1               NextChar:
000893  1  C4 21                        cpy     BUFLEN                  ; Any characters left?
000895  1  90 01                        bcc     *+3
000897  1  60                           rts
000898  1  B9 00 02                     lda     BUFFER,y
00089B  1  C8                           iny
00089C  1  4C C7 08                     jmp     ToUpperCase
00089F  1               
00089F  1               ; Skip over any spaces until a non-space character or the end of the string
00089F  1               ; is reached.
00089F  1               
00089F  1               SkipSpaces:
00089F  1  20 93 08                     jsr     NextChar                ; Fetch next character
0008A2  1  90 01                        bcc     *+3                     ; Any left?
0008A4  1  60                           rts                             ; No
0008A5  1  C9 20                        cmp     #' '                    ; Is it a space?
0008A7  1  F0 F6                        beq     SkipSpaces              ; Yes, try again
0008A9  1  18                           clc
0008AA  1  60                           rts                             ; Done
0008AB  1               
0008AB  1               ; Clear the buffer and the add the command character in A.
0008AB  1               
0008AB  1               StartCommand:
0008AB  1  64 21                        stz     BUFLEN                  ; Clear the character count
0008AD  1               
0008AD  1               ; Append the character in A to the command being built updating the length.
0008AD  1               
0008AD  1               BuildCommand:
0008AD  1  A4 21                        ldy     BUFLEN
0008AF  1  E6 21                        inc     BUFLEN
0008B1  1  99 00 02                     sta     BUFFER,y
0008B4  1  60                           rts
0008B5  1               
0008B5  1               ; Convert the value in A into hex characters and append to the command buffer.
0008B5  1               
0008B5  1               BuildByte:
0008B5  1  48                           pha                             ; Save the value
0008B6  1  4A                           lsr     a                       ; Shift MS nybble down
0008B7  1  4A                           lsr     a
0008B8  1  4A                           lsr     a
0008B9  1  4A                           lsr     a
0008BA  1  20 07 09                     jsr     HexToAscii              ; Convert to ASCII
0008BD  1  20 AD 08                     jsr     BuildCommand            ; .. and add to command
0008C0  1  68                           pla                             ; Pull LS nybble
0008C1  1  20 07 09                     jsr     HexToAscii              ; Convert to ASCII
0008C4  1  4C AD 08                     jmp     BuildCommand            ; .. and add to command
0008C7  1               
0008C7  1               ;===============================================================================
0008C7  1               ; Character Classification
0008C7  1               ;-------------------------------------------------------------------------------
0008C7  1               
0008C7  1               ; If the character in MD_ACC is lower case then convert it to upper case.
0008C7  1               
0008C7  1               ToUpperCase:
0008C7  1  20 D0 08                     jsr     IsLowerCase             ; Test the character
0008CA  1  90 02                        bcc     *+4
0008CC  1  E9 20                        sbc     #32                     ; Convert lower case
0008CE  1  18                           clc
0008CF  1  60                           rts                             ; Done
0008D0  1               
0008D0  1               ; Determine if the character in MD_ACC is a lower case letter. Set the carry if it
0008D0  1               ; is, otherwise clear it.
0008D0  1               
0008D0  1                               .a8
0008D0  1               IsLowerCase:
0008D0  1  C9 61                        cmp     #'a'                    ; Between a and z?
0008D2  1  90 06                        bcc     ClearCarry
0008D4  1  C9 7B                        cmp     #'z'+1
0008D6  1  B0 02                        bcs     ClearCarry
0008D8  1  38           SetCarry:       sec
0008D9  1  60                           rts
0008DA  1  18           ClearCarry:     clc
0008DB  1  60                           rts
0008DC  1               
0008DC  1               ; Determine if the character in MD_ACC is a hex character. Set the carry if it is,
0008DC  1               ; otherwise clear it.
0008DC  1               
0008DC  1                               .a8
0008DC  1               IsHexDigit:
0008DC  1  C9 30                        cmp     #'0'                    ; Between 0 and 9?
0008DE  1  90 FA                        bcc     ClearCarry
0008E0  1  C9 3A                        cmp     #'9'+1
0008E2  1  90 F4                        bcc     SetCarry
0008E4  1  C9 41                        cmp     #'A'                    ; Between MD_ACC and F?
0008E6  1  90 F2                        bcc     ClearCarry
0008E8  1  C9 47                        cmp     #'F'+1
0008EA  1  90 EC                        bcc     SetCarry
0008EC  1  80 EC                        bra     ClearCarry
0008EE  1               
0008EE  1               ; Determine if the character in MD_ACC is a printable character. Set the carry if it
0008EE  1               ; is, otherwise clear it.
0008EE  1               
0008EE  1                               .a8
0008EE  1               IsPrintable:
0008EE  1  C9 20                        cmp     #' '
0008F0  1  90 E8                        bcc     ClearCarry
0008F2  1  C9 7F                        cmp     #DEL
0008F4  1  90 E2                        bcc     SetCarry
0008F6  1  80 E2                        bra     ClearCarry
0008F8  1               
0008F8  1               ;===============================================================================
0008F8  1               ; Display Utilities
0008F8  1               ;-------------------------------------------------------------------------------
0008F8  1               
0008F8  1               ; Display the value in MD_ACC as two hexadecimal digits.
0008F8  1               
0008F8  1               TxHex2:
0008F8  1  48                           pha                             ; Save the original byte
0008F9  1  4A                           lsr     a                       ; Shift down hi nybble
0008FA  1  4A                           lsr     a
0008FB  1  4A                           lsr     a
0008FC  1  4A                           lsr     a
0008FD  1  20 01 09                     jsr     UartHex                 ; Display
000900  1  68                           pla                             ; Recover data byte
000901  1               
000901  1               ; Display the LSB of the value in MD_ACC as a hexadecimal digit using decimal
000901  1               ; arithmetic to do the conversion.
000901  1               
000901  1               UartHex:
000901  1  20 07 09                     jsr     HexToAscii              ; Convert to ASCII
000904  1  4C rr rr                     jmp     UartTx                  ; And display
000907  1               
000907  1               ; Convert a LSB of the value in MD_ACC to a hexadecimal digit using decimal
000907  1               ; arithmetic.
000907  1               
000907  1               HexToAscii:
000907  1  29 0F                        and     #$0f                    ; Strip out lo nybble
000909  1  F8                           sed                             ; Convert to ASCII
00090A  1  18                           clc
00090B  1  69 90                        adc     #$90
00090D  1  69 40                        adc     #$40
00090F  1  D8                           cld
000910  1  60                           rts                             ; Done
000911  1               
000911  1               ; Display the string of characters starting a the memory location pointed to by
000911  1               ; X (16-bits).
000911  1               
000911  1                               .a8
000911  1                               .i16
000911  1               TxStr:
000911  1  BD 00 00                     lda     a:0,x                     ; Fetch the next character
000914  1  D0 01                        bne     *+3                     ; Return it end of string
000916  1  60                           rts
000917  1  20 rr rr                     jsr     UartTx                  ; Otherwise print it
00091A  1  E8                           inx                             ; Bump the pointer
00091B  1  80 F4                        bra     TxStr                   ; And repeat
00091D  1               
00091D  1               ; Display a CR/LF control character s=ence.
00091D  1               
00091D  1               TxCRLF:
00091D  1  20 25 09                     jsr     TxCR                    ; Transmit a CR
000920  1  A9 0A                        lda     #LF                     ; Followed by a LF
000922  1  4C rr rr                     jmp     UartTx
000925  1               
000925  1               TxCR:
000925  1  A9 0D                        lda     #CR                     ; Transmit a CR
000927  1  4C rr rr                     jmp     UartTx
00092A  1               
00092A  1               TxSpace:
00092A  1  A9 20                        lda     #' '                    ; Transmit a space
00092C  1  4C rr rr                     jmp     UartTx
00092F  1               
00092F  1               ;===============================================================================
00092F  1               ;-------------------------------------------------------------------------------
00092F  1               
00092F  1               ;
00092F  1               
00092F  1                               .a8
00092F  1                               .i8
00092F  1               TxCodeBytes:
00092F  1  A7 23                        lda     [ADDR_S]                ; Fetch the opcode
000931  1  20 20 0B                     jsr     OpcodeSize              ; and work out its size
000934  1  AA                           tax
000935  1  A0 00                        ldy     #0                      ; Clear byte count
000937  1               CodeLoop:
000937  1  B7 23                        lda     [ADDR_S],Y              ; Fetch a byte of code
000939  1  20 F8 08                     jsr     TxHex2
00093C  1  20 2A 09                     jsr     TxSpace
00093F  1  C8                           iny
000940  1  CA                           dex
000941  1  D0 F4                        bne     CodeLoop
000943  1               PadLoop:
000943  1  C0 04                        cpy     #4                      ; Need to pad out?
000945  1  D0 01                        bne     *+3
000947  1  60                           rts
000948  1  20 2A 09                     jsr     TxSpace
00094B  1  20 2A 09                     jsr     TxSpace
00094E  1  20 2A 09                     jsr     TxSpace
000951  1  C8                           iny
000952  1  80 EF                        bra     PadLoop
000954  1               
000954  1               ;
000954  1               
000954  1                               .a8
000954  1                               .i8
000954  1               TxSymbolic:
000954  1  A7 23                        lda     [ADDR_S]                ; Fetch opcode
000956  1  48                           pha
000957  1  20 5F 09                     jsr     TxOpcode
00095A  1  68                           pla
00095B  1  20 90 09                     jsr     TxOperand
00095E  1  60                           rts
00095F  1               
00095F  1               ;
00095F  1               
00095F  1                               .a8
00095F  1                               .i8
00095F  1               TxOpcode:
00095F  1  08                           php                             ; Save register sizes
000960  1  AA                           tax                             ; Work out the mnemonic
000961  1  BD 76 0B                     lda     OPCODES,x
000964  1  AA                           tax
000965  1  C2 20                        long_a
000967  1  BD 76 0D                     lda     MNEMONICS,x
00096A  1               
00096A  1  48                           pha                             ; Save last character
00096B  1  4A                           lsr     a                       ; Shift second down
00096C  1  4A                           lsr     a
00096D  1  4A                           lsr     a
00096E  1  4A                           lsr     a
00096F  1  4A                           lsr     a
000970  1  48                           pha                             ; Save it
000971  1  4A                           lsr     a                       ; Shift first down
000972  1  4A                           lsr     a
000973  1  4A                           lsr     a
000974  1  4A                           lsr     a
000975  1  4A                           lsr     a
000976  1  20 86 09                     jsr     ExpandMnem              ; Print first
000979  1  68                           pla
00097A  1  20 86 09                     jsr     ExpandMnem              ; .. second
00097D  1  68                           pla
00097E  1  20 86 09                     jsr     ExpandMnem              ; .. and third
000981  1  28                           plp
000982  1  20 2A 09                     jsr     TxSpace
000985  1  60                           rts
000986  1               
000986  1               ExpandMnem:
000986  1  18                           clc
000987  1  29 1F 00                     and     #$1f                    ; Expand letter code
00098A  1  69 40 00                     adc     #'@'
00098D  1  4C rr rr                     jmp     UartTx
000990  1               
000990  1               ;
000990  1               
000990  1                               .a8
000990  1                               .i8
000990  1               TxOperand:
000990  1  AA                           tax                             ; Work out addressing mode
000991  1  BD 76 0C                     lda     MODES,x
000994  1  AA                           tax
000995  1  7C 98 09                     jmp     (MODE_SHOW,x)
000998  1               
000998  1               MODE_SHOW:
000998  1  3D 0A                        .word     TxAbsolute              ; a
00099A  1  CA 09                        .word     TxAccumulator           ; A
00099C  1  4F 0A                        .word     TxAbsoluteX             ; a,x
00099E  1  54 0A                        .word     TxAbsoluteY             ; a,y
0009A0  1  59 0A                        .word     TxLong                  ; al
0009A2  1  76 0A                        .word     TxLongX                 ; al,x
0009A4  1  7B 0A                        .word     TxAbsoluteIndirect      ; (a)
0009A6  1  88 0A                        .word     TxAbsoluteXIndirect     ; (a,x)
0009A8  1  17 0A                        .word     TxDirect                ; d
0009AA  1  0A 0A                        .word     TxStack                 ; d,s
0009AC  1  23 0A                        .word     TxDirectX               ; d,x
0009AE  1  30 0A                        .word     TxDirectY               ; d,y
0009B0  1  95 0A                        .word     TxDirectIndirect        ; (d)
0009B2  1  BF 0A                        .word     TxDirectIndirectLong    ; [d]
0009B4  1  D2 0A                        .word     TxStackIndirectY        ; (d,s),y
0009B6  1  A2 0A                        .word     TxDirectXIndirect       ; (d,x)
0009B8  1  AF 0A                        .word     TxDirectIndirectY       ; (d),y
0009BA  1  CC 0A                        .word     TxDirectIndirectLongY   ; [d],y
0009BC  1  DF 09                        .word     TxImplied               ;
0009BE  1  E2 0A                        .word     TxRelative              ; r
0009C0  1  FE 0A                        .word     TxRelativeLong          ; rl
0009C2  1  E0 09                        .word     TxMove                  ; xyc
0009C4  1  CF 09                        .word     TxImmediateM            ; # (A & M)
0009C6  1  FC 09                        .word     TxImmediateByte         ; # (BRK/COP/WDM)
0009C8  1  D7 09                        .word     TxImmediateX            ; # (X or Y)
0009CA  1               
0009CA  1               
0009CA  1               TxAccumulator:
0009CA  1  A9 41                        lda     #'A'
0009CC  1  4C rr rr                     jmp     UartTx
0009CF  1               
0009CF  1               TxImmediateM:
0009CF  1  A9 20                        lda     #M_FLAG
0009D1  1  24 20                        bit     FLAGS
0009D3  1  F0 2E                        beq     TxImmediateWord
0009D5  1  80 25                        bra     TxImmediateByte
0009D7  1               
0009D7  1               TxImmediateX:
0009D7  1  A9 10                        lda     #X_FLAG
0009D9  1  24 20                        bit     FLAGS
0009DB  1  F0 26                        beq     TxImmediateWord
0009DD  1  80 1D                        bra     TxImmediateByte
0009DF  1               
0009DF  1               TxImplied:
0009DF  1  60                           rts
0009E0  1               
0009E0  1               TxMove:
0009E0  1  A9 24                        lda     #'$'
0009E2  1  20 rr rr                     jsr     UartTx
0009E5  1  A0 01                        ldy     #1
0009E7  1  B7 23                        lda     [ADDR_S],Y
0009E9  1  20 F8 08                     jsr     TxHex2
0009EC  1  A9 2C                        lda     #','
0009EE  1  20 rr rr                     jsr     UartTx
0009F1  1  A9 24                        lda     #'$'
0009F3  1  20 rr rr                     jsr     UartTx
0009F6  1  C8                           iny
0009F7  1  B7 23                        lda     [ADDR_S],Y
0009F9  1  4C F8 08                     jmp     TxHex2
0009FC  1               
0009FC  1               TxImmediateByte:
0009FC  1  A9 23                        lda     #'#'
0009FE  1  20 rr rr                     jsr     UartTx
000A01  1  80 14                        bra     TxDirect
000A03  1               
000A03  1               TxImmediateWord:
000A03  1  A9 23                        lda     #'#'
000A05  1  20 rr rr                     jsr     UartTx
000A08  1  80 33                        bra     TxAbsolute
000A0A  1               
000A0A  1               TxStack:
000A0A  1  20 17 0A                     jsr     TxDirect
000A0D  1  A9 2C                        lda     #','
000A0F  1  20 rr rr                     jsr     UartTx
000A12  1  A9 53                        lda     #'S'
000A14  1  4C rr rr                     jmp     UartTx
000A17  1               
000A17  1               TxDirect:
000A17  1  A9 24                        lda     #'$'
000A19  1  20 rr rr                     jsr     UartTx
000A1C  1  A0 01                        ldy     #1
000A1E  1  B7 23                        lda     [ADDR_S],Y
000A20  1  4C F8 08                     jmp     TxHex2
000A23  1               
000A23  1               TxDirectX:
000A23  1  20 17 0A                     jsr     TxDirect
000A26  1  A9 2C        TxX:            lda     #','
000A28  1  20 rr rr                     jsr     UartTx
000A2B  1  A9 58                        lda     #'X'
000A2D  1  4C rr rr                     jmp     UartTx
000A30  1               
000A30  1               TxDirectY:
000A30  1  20 17 0A                     jsr     TxDirect
000A33  1  A9 2C        TxY_:           lda     #','
000A35  1  20 rr rr                     jsr     UartTx
000A38  1  A9 59                        lda     #'Y'
000A3A  1  4C rr rr                     jmp     UartTx
000A3D  1               
000A3D  1               TxAbsolute:
000A3D  1  A9 24                        lda     #'$'
000A3F  1  20 rr rr                     jsr     UartTx
000A42  1  A0 02                        ldy     #2
000A44  1  B7 23                        lda     [ADDR_S],Y
000A46  1  20 F8 08                     jsr     TxHex2
000A49  1  88                           dey
000A4A  1  B7 23                        lda     [ADDR_S],Y
000A4C  1  4C F8 08                     jmp     TxHex2
000A4F  1               
000A4F  1               TxAbsoluteX:
000A4F  1  20 3D 0A                     jsr     TxAbsolute
000A52  1  80 D2                        bra     TxX
000A54  1               
000A54  1               TxAbsoluteY:
000A54  1  20 3D 0A                     jsr     TxAbsolute
000A57  1  80 DA                        bra     TxY_
000A59  1               
000A59  1               TxLong:
000A59  1  A9 24                        lda     #'$'
000A5B  1  20 rr rr                     jsr     UartTx
000A5E  1  A0 03                        ldy     #3
000A60  1  B7 23                        lda     [ADDR_S],Y
000A62  1  20 F8 08                     jsr     TxHex2
000A65  1  A9 3A                        lda     #':'
000A67  1  20 rr rr                     jsr     UartTx
000A6A  1  88                           dey
000A6B  1  B7 23                        lda     [ADDR_S],Y
000A6D  1  20 F8 08                     jsr     TxHex2
000A70  1  88                           dey
000A71  1  B7 23                        lda     [ADDR_S],Y
000A73  1  4C F8 08                     jmp     TxHex2
000A76  1               
000A76  1               TxLongX:
000A76  1  20 59 0A                     jsr     TxLong
000A79  1  80 AB                        bra     TxX
000A7B  1               
000A7B  1               TxAbsoluteIndirect:
000A7B  1  A9 28                        lda     #'('
000A7D  1  20 rr rr                     jsr     UartTx
000A80  1  20 3D 0A                     jsr     TxAbsolute
000A83  1  A9 29                        lda     #')'
000A85  1  4C rr rr                     jmp     UartTx
000A88  1               
000A88  1               TxAbsoluteXIndirect:
000A88  1  A9 28                        lda     #'('
000A8A  1  20 rr rr                     jsr     UartTx
000A8D  1  20 4F 0A                     jsr     TxAbsoluteX
000A90  1  A9 29                        lda     #')'
000A92  1  4C rr rr                     jmp     UartTx
000A95  1               
000A95  1               TxDirectIndirect:
000A95  1  A9 28                        lda     #'('
000A97  1  20 rr rr                     jsr     UartTx
000A9A  1  20 17 0A                     jsr     TxDirect
000A9D  1  A9 29                        lda     #')'
000A9F  1  4C rr rr                     jmp     UartTx
000AA2  1               
000AA2  1               TxDirectXIndirect:
000AA2  1  A9 28                        lda     #'('
000AA4  1  20 rr rr                     jsr     UartTx
000AA7  1  20 23 0A                     jsr     TxDirectX
000AAA  1  A9 29                        lda     #')'
000AAC  1  4C rr rr                     jmp     UartTx
000AAF  1               
000AAF  1               TxDirectIndirectY:
000AAF  1  A9 28                        lda     #'('
000AB1  1  20 rr rr                     jsr     UartTx
000AB4  1  20 17 0A                     jsr     TxDirect
000AB7  1  A9 29                        lda     #')'
000AB9  1  20 rr rr                     jsr     UartTx
000ABC  1  4C 33 0A                     jmp     TxY_
000ABF  1               
000ABF  1               TxDirectIndirectLong:
000ABF  1  A9 5B                        lda     #'['
000AC1  1  20 rr rr                     jsr     UartTx
000AC4  1  20 17 0A                     jsr     TxDirect
000AC7  1  A9 5D                        lda     #']'
000AC9  1  4C rr rr                     jmp     UartTx
000ACC  1               
000ACC  1               TxDirectIndirectLongY:
000ACC  1  20 BF 0A                     jsr     TxDirectIndirectLong
000ACF  1  4C 33 0A                     jmp     TxY_
000AD2  1               
000AD2  1               TxStackIndirectY:
000AD2  1  A9 28                        lda     #'('
000AD4  1  20 rr rr                     jsr     UartTx
000AD7  1  20 0A 0A                     jsr     TxStack
000ADA  1  A9 29                        lda     #')'
000ADC  1  20 rr rr                     jsr     UartTx
000ADF  1  4C 33 0A                     jmp     TxY_
000AE2  1               
000AE2  1               TxRelative:
000AE2  1  A6 24                        ldx     ADDR_S+1                ; Work out next PC
000AE4  1  A5 23                        lda     ADDR_S+0
000AE6  1  18                           clc
000AE7  1  69 02                        adc     #2
000AE9  1  90 01                        bcc     *+3
000AEB  1  E8                           inx
000AEC  1               
000AEC  1  48                           pha                             ; Add relative offset
000AED  1  A0 01                        ldy     #1
000AEF  1  B7 23                        lda     [ADDR_S],y
000AF1  1  10 01                        bpl     *+3
000AF3  1  CA                           dex
000AF4  1  18                           clc
000AF5  1  63 01                        adc     1,s
000AF7  1  83 01                        sta     1,s
000AF9  1  90 01                        bcc     *+3
000AFB  1  E8                           inx
000AFC  1  80 15                        bra     TxAddr
000AFE  1               
000AFE  1               TxRelativeLong:
000AFE  1  A6 24                        ldx     ADDR_S+1                ; Work out next PC
000B00  1  A5 23                        lda     ADDR_S+0
000B02  1  18                           clc
000B03  1  69 03                        adc     #3
000B05  1  90 01                        bcc     *+3
000B07  1  E8                           inx
000B08  1               
000B08  1  18                           clc                             ; Add relative offset
000B09  1  A0 01                        ldy     #1
000B0B  1  77 23                        adc     [ADDR_S],y
000B0D  1  48                           pha
000B0E  1  C8                           iny
000B0F  1  8A                           txa
000B10  1  77 23                        adc     [ADDR_S],Y
000B12  1  AA                           tax
000B13  1               
000B13  1               TxAddr:
000B13  1  A9 24                        lda     #'$'                    ; Print address
000B15  1  20 rr rr                     jsr     UartTx
000B18  1  8A                           txa
000B19  1  20 F8 08                     jsr     TxHex2
000B1C  1  68                           pla
000B1D  1  4C F8 08                     jmp     TxHex2
000B20  1               
000B20  1               ;  Returns the size of the opcode in A given the current flag settings.
000B20  1               
000B20  1                               .a8
000B20  1                               .i8
000B20  1               OpcodeSize:
000B20  1  AA                           tax                             ; Work out addressing mode
000B21  1  BD 76 0C                     lda     MODES,x
000B24  1  AA                           tax
000B25  1  7C 28 0B                     jmp     (MODE_SIZE,x)
000B28  1               
000B28  1               MODE_SIZE:
000B28  1  70 0B                        .word     Size3                   ; a
000B2A  1  6A 0B                        .word     Size1                   ; A
000B2C  1  70 0B                        .word     Size3                   ; a,x
000B2E  1  70 0B                        .word     Size3                   ; a,y
000B30  1  73 0B                        .word     Size4                   ; al
000B32  1  73 0B                        .word     Size4                   ; al,x
000B34  1  70 0B                        .word     Size3                   ; (a)
000B36  1  70 0B                        .word     Size3                   ; (a,x)
000B38  1  6D 0B                        .word     Size2                   ; d
000B3A  1  6D 0B                        .word     Size2                   ; d,s
000B3C  1  6D 0B                        .word     Size2                   ; d,x
000B3E  1  6D 0B                        .word     Size2                   ; d,y
000B40  1  6D 0B                        .word     Size2                   ; (d)
000B42  1  6D 0B                        .word     Size2                   ; [d]
000B44  1  6D 0B                        .word     Size2                   ; (d,s),y
000B46  1  6D 0B                        .word     Size2                   ; (d,x)
000B48  1  6D 0B                        .word     Size2                   ; (d),y
000B4A  1  6D 0B                        .word     Size2                   ; [d],y
000B4C  1  6A 0B                        .word     Size1                   ;
000B4E  1  6D 0B                        .word     Size2                   ; r
000B50  1  70 0B                        .word     Size3                   ; rl
000B52  1  70 0B                        .word     Size3                   ; xyc
000B54  1  5A 0B                        .word     TestM                   ; # (A & M)
000B56  1  6D 0B                        .word     Size2                   ; # (BRK/COP/WDM)
000B58  1  62 0B                        .word     TestX                   ; # (X or Y)
000B5A  1               
000B5A  1               TestM:
000B5A  1  A9 20                        lda     #M_FLAG                 ; Is M bit set?
000B5C  1  25 20                        and     FLAGS
000B5E  1  F0 10                        beq     Size3                   ; No, word
000B60  1  80 0B                        bra     Size2                   ; else byte
000B62  1               
000B62  1               TestX:
000B62  1  A9 10                        lda     #X_FLAG                 ; Is X bit set?
000B64  1  25 20                        and     FLAGS
000B66  1  F0 08                        beq     Size3                   ; No, word
000B68  1  80 03                        bra     Size2                   ; else byte
000B6A  1               
000B6A  1  A9 01        Size1:          lda     #1
000B6C  1  60                           rts
000B6D  1  A9 02        Size2:          lda     #2
000B6F  1  60                           rts
000B70  1  A9 03        Size3:          lda     #3
000B72  1  60                           rts
000B73  1  A9 04        Size4:          lda     #4
000B75  1  60                           rts
000B76  1               
000B76  1               OPCODES:
000B76  1  16 52 28 52                  .byte      OP_BRK,OP_ORA,OP_COP,OP_ORA     ; 00
000B7A  1  A0 52 04 52                  .byte      OP_TSB,OP_ORA,OP_ASL,OP_ORA
000B7E  1  62 52 04 5E                  .byte      OP_PHP,OP_ORA,OP_ASL,OP_PHD
000B82  1  A0 52 04 52                  .byte      OP_TSB,OP_ORA,OP_ASL,OP_ORA
000B86  1  12 52 52 52                  .byte      OP_BPL,OP_ORA,OP_ORA,OP_ORA     ; 10
000B8A  1  9E 52 04 52                  .byte      OP_TRB,OP_ORA,OP_ASL,OP_ORA
000B8E  1  1E 52 36 9A                  .byte      OP_CLC,OP_ORA,OP_INC,OP_TCS
000B92  1  9E 52 04 52                  .byte      OP_TRB,OP_ORA,OP_ASL,OP_ORA
000B96  1  42 02 40 02                  .byte      OP_JSR,OP_AND,OP_JSL,OP_AND     ; 20
000B9A  1  0C 02 76 02                  .byte      OP_BIT,OP_AND,OP_ROL,OP_AND
000B9E  1  6E 02 76 6C                  .byte      OP_PLP,OP_AND,OP_ROL,OP_PLD
000BA2  1  0C 02 76 02                  .byte      OP_BIT,OP_AND,OP_ROL,OP_AND
000BA6  1  0E 02 02 02                  .byte      OP_BMI,OP_AND,OP_AND,OP_AND     ; 30
000BAA  1  0C 02 76 02                  .byte      OP_BIT,OP_AND,OP_ROL,OP_AND
000BAE  1  82 02 2E A2                  .byte      OP_SEC,OP_AND,OP_DEC,OP_TSC
000BB2  1  0C 02 76 02                  .byte      OP_BIT,OP_AND,OP_ROL,OP_AND
000BB6  1  7A 34 B2 34                  .byte      OP_RTI,OP_EOR,OP_WDM,OP_EOR     ; 40
000BBA  1  4E 34 4A 34                  .byte      OP_MVP,OP_EOR,OP_LSR,OP_EOR
000BBE  1  5A 34 4A 60                  .byte      OP_PHA,OP_EOR,OP_LSR,OP_PHK
000BC2  1  3E 34 4A 34                  .byte      OP_JMP,OP_EOR,OP_LSR,OP_EOR
000BC6  1  1A 34 34 34                  .byte      OP_BVC,OP_EOR,OP_EOR,OP_EOR     ; 50
000BCA  1  4C 34 4A 34                  .byte      OP_MVN,OP_EOR,OP_LSR,OP_EOR
000BCE  1  22 34 66 98                  .byte      OP_CLI,OP_EOR,OP_PHY,OP_TCD
000BD2  1  3E 34 4A 34                  .byte      OP_JMP,OP_EOR,OP_LSR,OP_EOR
000BD6  1  7E 00 58 00                  .byte      OP_RTS,OP_ADC,OP_PER,OP_ADC     ; 60
000BDA  1  92 00 78 00                  .byte      OP_STZ,OP_ADC,OP_ROR,OP_ADC
000BDE  1  68 00 78 7C                  .byte      OP_PLA,OP_ADC,OP_ROR,OP_RTL
000BE2  1  3E 00 78 00                  .byte      OP_JMP,OP_ADC,OP_ROR,OP_ADC
000BE6  1  1C 00 00 00                  .byte      OP_BVS,OP_ADC,OP_ADC,OP_ADC     ; 70
000BEA  1  92 00 78 00                  .byte      OP_STZ,OP_ADC,OP_ROR,OP_ADC
000BEE  1  86 00 72 9C                  .byte      OP_SEI,OP_ADC,OP_PLY,OP_TDC
000BF2  1  3E 00 78 00                  .byte      OP_JMP,OP_ADC,OP_ROR,OP_ADC
000BF6  1  14 8A 18 8A                  .byte      OP_BRA,OP_STA,OP_BRL,OP_STA     ; 80
000BFA  1  90 8A 8E 8A                  .byte      OP_STY,OP_STA,OP_STX,OP_STA
000BFE  1  32 0C A6 5C                  .byte      OP_DEY,OP_BIT,OP_TXA,OP_PHB
000C02  1  90 8A 8E 8A                  .byte      OP_STY,OP_STA,OP_STX,OP_STA
000C06  1  06 8A 8A 8A                  .byte      OP_BCC,OP_STA,OP_STA,OP_STA     ; 90
000C0A  1  90 8A 8E 8A                  .byte      OP_STY,OP_STA,OP_STX,OP_STA
000C0E  1  AC 8A A8 AA                  .byte      OP_TYA,OP_STA,OP_TXS,OP_TXY
000C12  1  92 8A 92 8A                  .byte      OP_STZ,OP_STA,OP_STZ,OP_STA
000C16  1  48 44 46 44                  .byte      OP_LDY,OP_LDA,OP_LDX,OP_LDA     ; A0
000C1A  1  48 44 46 44                  .byte      OP_LDY,OP_LDA,OP_LDX,OP_LDA
000C1E  1  96 44 94 6A                  .byte      OP_TAY,OP_LDA,OP_TAX,OP_PLB
000C22  1  48 44 46 44                  .byte      OP_LDY,OP_LDA,OP_LDX,OP_LDA
000C26  1  08 44 44 44                  .byte      OP_BCS,OP_LDA,OP_LDA,OP_LDA     ; B0
000C2A  1  44 48 46 44                  .byte      OP_LDA,OP_LDY,OP_LDX,OP_LDA
000C2E  1  24 44 A4 AE                  .byte      OP_CLV,OP_LDA,OP_TSX,OP_TYX
000C32  1  48 44 46 44                  .byte      OP_LDY,OP_LDA,OP_LDX,OP_LDA
000C36  1  2C 26 74 26                  .byte      OP_CPY,OP_CMP,OP_REP,OP_CMP     ; C0
000C3A  1  2C 26 2E 26                  .byte      OP_CPY,OP_CMP,OP_DEC,OP_CMP
000C3E  1  3A 26 30 B0                  .byte      OP_INY,OP_CMP,OP_DEX,OP_WAI
000C42  1  2C 26 2E 26                  .byte      OP_CPY,OP_CMP,OP_DEC,OP_CMP
000C46  1  10 26 26 26                  .byte      OP_BNE,OP_CMP,OP_CMP,OP_CMP     ; D0
000C4A  1  56 26 2E 26                  .byte      OP_PEI,OP_CMP,OP_DEC,OP_CMP
000C4E  1  20 26 64 8C                  .byte      OP_CLD,OP_CMP,OP_PHX,OP_STP
000C52  1  3C 26 2E 26                  .byte      OP_JML,OP_CMP,OP_DEC,OP_CMP
000C56  1  2A 80 88 80                  .byte      OP_CPX,OP_SBC,OP_SEP,OP_SBC     ; E0
000C5A  1  2A 80 36 80                  .byte      OP_CPX,OP_SBC,OP_INC,OP_SBC
000C5E  1  38 80 50 B4                  .byte      OP_INX,OP_SBC,OP_NOP,OP_XBA
000C62  1  2A 80 36 80                  .byte      OP_CPX,OP_SBC,OP_INC,OP_SBC
000C66  1  0A 80 80 80                  .byte      OP_BEQ,OP_SBC,OP_SBC,OP_SBC     ; F0
000C6A  1  54 80 36 80                  .byte      OP_PEA,OP_SBC,OP_INC,OP_SBC
000C6E  1  84 80 70 B6                  .byte      OP_SED,OP_SBC,OP_PLX,OP_XCE
000C72  1  42 80 36 80                  .byte      OP_JSR,OP_SBC,OP_INC,OP_SBC
000C76  1               
000C76  1               MODES:
000C76  1  2E 1E 2E 12                  .byte      MD_INT,MD_DIX,MD_INT,MD_STK     ; 00
000C7A  1  10 10 10 1A                  .byte      MD_DPG,MD_DPG,MD_DPG,MD_DLI
000C7E  1  24 2C 02 24                  .byte      MD_IMP,MD_IMM,MD_ACC,MD_IMP
000C82  1  00 00 00 08                  .byte      MD_ABS,MD_ABS,MD_ABS,MD_ALG
000C86  1  26 20 18 1C                  .byte      MD_REL,MD_DIY,MD_DIN,MD_SKY     ; 10
000C8A  1  10 14 14 22                  .byte      MD_DPG,MD_DPX,MD_DPX,MD_DLY
000C8E  1  24 06 02 24                  .byte      MD_IMP,MD_ABY,MD_ACC,MD_IMP
000C92  1  00 04 04 0A                  .byte      MD_ABS,MD_ABX,MD_ABX,MD_ALX
000C96  1  00 1E 08 12                  .byte      MD_ABS,MD_DIX,MD_ALG,MD_STK     ; 20
000C9A  1  10 10 10 1A                  .byte      MD_DPG,MD_DPG,MD_DPG,MD_DLI
000C9E  1  24 2C 02 24                  .byte      MD_IMP,MD_IMM,MD_ACC,MD_IMP
000CA2  1  00 00 00 08                  .byte      MD_ABS,MD_ABS,MD_ABS,MD_ALG
000CA6  1  26 20 18 1C                  .byte      MD_REL,MD_DIY,MD_DIN,MD_SKY     ; 30
000CAA  1  14 14 14 22                  .byte      MD_DPX,MD_DPX,MD_DPX,MD_DLY
000CAE  1  24 06 02 24                  .byte      MD_IMP,MD_ABY,MD_ACC,MD_IMP
000CB2  1  04 04 04 0A                  .byte      MD_ABX,MD_ABX,MD_ABX,MD_ALX
000CB6  1  24 1E 2E 12                  .byte      MD_IMP,MD_DIX,MD_INT,MD_STK     ; 40
000CBA  1  2A 10 10 1A                  .byte      MD_MOV,MD_DPG,MD_DPG,MD_DLI
000CBE  1  24 2C 02 24                  .byte      MD_IMP,MD_IMM,MD_ACC,MD_IMP
000CC2  1  00 00 00 08                  .byte      MD_ABS,MD_ABS,MD_ABS,MD_ALG
000CC6  1  26 20 18 1C                  .byte      MD_REL,MD_DIY,MD_DIN,MD_SKY     ; 50
000CCA  1  2A 14 14 22                  .byte      MD_MOV,MD_DPX,MD_DPX,MD_DLY
000CCE  1  24 06 24 24                  .byte      MD_IMP,MD_ABY,MD_IMP,MD_IMP
000CD2  1  08 04 04 0A                  .byte      MD_ALG,MD_ABX,MD_ABX,MD_ALX
000CD6  1  24 1E 24 12                  .byte      MD_IMP,MD_DIX,MD_IMP,MD_STK     ; 60
000CDA  1  10 10 10 1A                  .byte      MD_DPG,MD_DPG,MD_DPG,MD_DLI
000CDE  1  24 2C 02 24                  .byte      MD_IMP,MD_IMM,MD_ACC,MD_IMP
000CE2  1  0C 00 00 08                  .byte      MD_AIN,MD_ABS,MD_ABS,MD_ALG
000CE6  1  26 20 18 1C                  .byte      MD_REL,MD_DIY,MD_DIN,MD_SKY     ; 70
000CEA  1  14 14 14 22                  .byte      MD_DPX,MD_DPX,MD_DPX,MD_DLY
000CEE  1  24 06 24 24                  .byte      MD_IMP,MD_ABY,MD_IMP,MD_IMP
000CF2  1  0E 04 04 0A                  .byte      MD_AIX,MD_ABX,MD_ABX,MD_ALX
000CF6  1  26 1E 28 12                  .byte      MD_REL,MD_DIX,MD_RLG,MD_STK     ; 80
000CFA  1  10 10 10 1A                  .byte      MD_DPG,MD_DPG,MD_DPG,MD_DLI
000CFE  1  24 2C 24 24                  .byte      MD_IMP,MD_IMM,MD_IMP,MD_IMP
000D02  1  00 00 00 08                  .byte      MD_ABS,MD_ABS,MD_ABS,MD_ALG
000D06  1  26 20 18 1C                  .byte      MD_REL,MD_DIY,MD_DIN,MD_SKY     ; 90
000D0A  1  14 14 16 22                  .byte      MD_DPX,MD_DPX,MD_DPY,MD_DLY
000D0E  1  24 06 24 24                  .byte      MD_IMP,MD_ABY,MD_IMP,MD_IMP
000D12  1  00 04 04 0A                  .byte      MD_ABS,MD_ABX,MD_ABX,MD_ALX
000D16  1  30 1E 30 12                  .byte      MD_IMX,MD_DIX,MD_IMX,MD_STK     ; A0
000D1A  1  10 10 10 1A                  .byte      MD_DPG,MD_DPG,MD_DPG,MD_DLI
000D1E  1  24 2C 24 24                  .byte      MD_IMP,MD_IMM,MD_IMP,MD_IMP
000D22  1  00 00 00 08                  .byte      MD_ABS,MD_ABS,MD_ABS,MD_ALG
000D26  1  26 20 18 1C                  .byte      MD_REL,MD_DIY,MD_DIN,MD_SKY     ; B0
000D2A  1  14 14 16 22                  .byte      MD_DPX,MD_DPX,MD_DPY,MD_DLY
000D2E  1  24 06 24 24                  .byte      MD_IMP,MD_ABY,MD_IMP,MD_IMP
000D32  1  04 04 06 0A                  .byte      MD_ABX,MD_ABX,MD_ABY,MD_ALX
000D36  1  30 1E 2E 12                  .byte      MD_IMX,MD_DIX,MD_INT,MD_STK     ; C0
000D3A  1  10 10 10 1A                  .byte      MD_DPG,MD_DPG,MD_DPG,MD_DLI
000D3E  1  24 2C 24 24                  .byte      MD_IMP,MD_IMM,MD_IMP,MD_IMP
000D42  1  00 00 00 08                  .byte      MD_ABS,MD_ABS,MD_ABS,MD_ALG
000D46  1  26 20 18 1C                  .byte      MD_REL,MD_DIY,MD_DIN,MD_SKY     ; D0
000D4A  1  24 14 14 22                  .byte      MD_IMP,MD_DPX,MD_DPX,MD_DLY
000D4E  1  24 06 24 24                  .byte      MD_IMP,MD_ABY,MD_IMP,MD_IMP
000D52  1  0C 04 04 0A                  .byte      MD_AIN,MD_ABX,MD_ABX,MD_ALX
000D56  1  30 1E 2E 12                  .byte      MD_IMX,MD_DIX,MD_INT,MD_STK     ; E0
000D5A  1  10 10 10 1A                  .byte      MD_DPG,MD_DPG,MD_DPG,MD_DLI
000D5E  1  24 2C 24 24                  .byte      MD_IMP,MD_IMM,MD_IMP,MD_IMP
000D62  1  00 00 00 08                  .byte      MD_ABS,MD_ABS,MD_ABS,MD_ALG
000D66  1  26 20 18 1C                  .byte      MD_REL,MD_DIY,MD_DIN,MD_SKY     ; F0
000D6A  1  24 14 14 22                  .byte      MD_IMP,MD_DPX,MD_DPX,MD_DLY
000D6E  1  24 06 24 24                  .byte      MD_IMP,MD_ABY,MD_IMP,MD_IMP
000D72  1  0E 04 04 0A                  .byte      MD_AIX,MD_ABX,MD_ABX,MD_ALX
000D76  1               
000D76  1               MNEMONICS:
000D76  1  83 04                        MNEM    'A','D','C'
000D78  1  C4 05                        MNEM    'A','N','D'
000D7A  1  6C 06                        MNEM    'A','S','L'
000D7C  1  63 08                        MNEM    'B','C','C'
000D7E  1  73 08                        MNEM    'B','C','S'
000D80  1  B1 08                        MNEM    'B','E','Q'
000D82  1  34 09                        MNEM    'B','I','T'
000D84  1  A9 09                        MNEM    'B','M','I'
000D86  1  C5 09                        MNEM    'B','N','E'
000D88  1  0C 0A                        MNEM    'B','P','L'
000D8A  1  41 0A                        MNEM    'B','R','A'
000D8C  1  4B 0A                        MNEM    'B','R','K'
000D8E  1  4C 0A                        MNEM    'B','R','L'
000D90  1  C3 0A                        MNEM    'B','V','C'
000D92  1  D3 0A                        MNEM    'B','V','S'
000D94  1  83 0D                        MNEM    'C','L','C'
000D96  1  84 0D                        MNEM    'C','L','D'
000D98  1  89 0D                        MNEM    'C','L','I'
000D9A  1  96 0D                        MNEM    'C','L','V'
000D9C  1  B0 0D                        MNEM    'C','M','P'
000D9E  1  F0 0D                        MNEM    'C','O','P'
000DA0  1  18 0E                        MNEM    'C','P','X'
000DA2  1  19 0E                        MNEM    'C','P','Y'
000DA4  1  A3 10                        MNEM    'D','E','C'
000DA6  1  B8 10                        MNEM    'D','E','X'
000DA8  1  B9 10                        MNEM    'D','E','Y'
000DAA  1  F2 15                        MNEM    'E','O','R'
000DAC  1  C3 25                        MNEM    'I','N','C'
000DAE  1  D8 25                        MNEM    'I','N','X'
000DB0  1  D9 25                        MNEM    'I','N','Y'
000DB2  1  AC 29                        MNEM    'J','M','L'
000DB4  1  B0 29                        MNEM    'J','M','P'
000DB6  1  6C 2A                        MNEM    'J','S','L'
000DB8  1  72 2A                        MNEM    'J','S','R'
000DBA  1  81 30                        MNEM    'L','D','A'
000DBC  1  98 30                        MNEM    'L','D','X'
000DBE  1  99 30                        MNEM    'L','D','Y'
000DC0  1  72 32                        MNEM    'L','S','R'
000DC2  1  CE 36                        MNEM    'M','V','N'
000DC4  1  D0 36                        MNEM    'M','V','P'
000DC6  1  F0 39                        MNEM    'N','O','P'
000DC8  1  41 3E                        MNEM    'O','R','A'
000DCA  1  A1 40                        MNEM    'P','E','A'
000DCC  1  A9 40                        MNEM    'P','E','I'
000DCE  1  B2 40                        MNEM    'P','E','R'
000DD0  1  01 41                        MNEM    'P','H','A'
000DD2  1  02 41                        MNEM    'P','H','B'
000DD4  1  04 41                        MNEM    'P','H','D'
000DD6  1  0B 41                        MNEM    'P','H','K'
000DD8  1  10 41                        MNEM    'P','H','P'
000DDA  1  18 41                        MNEM    'P','H','X'
000DDC  1  19 41                        MNEM    'P','H','Y'
000DDE  1  81 41                        MNEM    'P','L','A'
000DE0  1  82 41                        MNEM    'P','L','B'
000DE2  1  84 41                        MNEM    'P','L','D'
000DE4  1  90 41                        MNEM    'P','L','P'
000DE6  1  98 41                        MNEM    'P','L','X'
000DE8  1  99 41                        MNEM    'P','L','Y'
000DEA  1  B0 48                        MNEM    'R','E','P'
000DEC  1  EC 49                        MNEM    'R','O','L'
000DEE  1  F2 49                        MNEM    'R','O','R'
000DF0  1  89 4A                        MNEM    'R','T','I'
000DF2  1  8C 4A                        MNEM    'R','T','L'
000DF4  1  93 4A                        MNEM    'R','T','S'
000DF6  1  43 4C                        MNEM    'S','B','C'
000DF8  1  A3 4C                        MNEM    'S','E','C'
000DFA  1  A4 4C                        MNEM    'S','E','D'
000DFC  1  A9 4C                        MNEM    'S','E','I'
000DFE  1  B0 4C                        MNEM    'S','E','P'
000E00  1  81 4E                        MNEM    'S','T','A'
000E02  1  90 4E                        MNEM    'S','T','P'
000E04  1  98 4E                        MNEM    'S','T','X'
000E06  1  99 4E                        MNEM    'S','T','Y'
000E08  1  9A 4E                        MNEM    'S','T','Z'
000E0A  1  38 50                        MNEM    'T','A','X'
000E0C  1  39 50                        MNEM    'T','A','Y'
000E0E  1  64 50                        MNEM    'T','C','D'
000E10  1  73 50                        MNEM    'T','C','S'
000E12  1  83 50                        MNEM    'T','D','C'
000E14  1  42 52                        MNEM    'T','R','B'
000E16  1  62 52                        MNEM    'T','S','B'
000E18  1  63 52                        MNEM    'T','S','C'
000E1A  1  78 52                        MNEM    'T','S','X'
000E1C  1  01 53                        MNEM    'T','X','A'
000E1E  1  13 53                        MNEM    'T','X','S'
000E20  1  19 53                        MNEM    'T','X','Y'
000E22  1  21 53                        MNEM    'T','Y','A'
000E24  1  38 53                        MNEM    'T','Y','X'
000E26  1  29 5C                        MNEM    'W','A','I'
000E28  1  8D 5C                        MNEM    'W','D','M'
000E2A  1  41 60                        MNEM    'X','B','A'
000E2C  1  65 60                        MNEM    'X','C','E'
000E2E  1               
000E2E  1               ;===============================================================================
000E2E  1               ; String Literals
000E2E  1               ;-------------------------------------------------------------------------------
000E2E  1               
000E2E  1  0D 0A        TITLE:          .byte      CR,LF
000E30  1                               .ifdef   W65C265SXB
000E30  1                               .byte      "W65C265SXB"
000E30  1                               .else
000E30  1  57 36 35 43                  .byte      "W65C816SXB"
000E34  1  38 31 36 53  
000E38  1  58 42        
000E3A  1                               .endif
000E3A  1  2D 48 61 63                  .byte      "-Hacker [18.06]",0
000E3E  1  6B 65 72 20  
000E42  1  5B 31 38 2E  
000E4A  1               
000E4A  1  0D 0A 45 72  ERROR:          .byte      CR,LF,"Error - Type ? for help",0
000E4E  1  72 6F 72 20  
000E52  1  2D 20 54 79  
000E64  1               
000E64  1  0D 0A 45 72  ERASE_FAILED:   .byte      CR,LF,"Erase failed",0
000E68  1  61 73 65 20  
000E6C  1  66 61 69 6C  
000E73  1  0D 0A 57 72  WRITE_FAILED:   .byte      CR,LF,"Write failed",0
000E77  1  69 74 65 20  
000E7B  1  66 61 69 6C  
000E82  1  0D 0A 57 44  NOT_SAFE:       .byte      CR,LF,"WDC ROM Bank Selected",0
000E86  1  43 20 52 4F  
000E8A  1  4D 20 42 61  
000E9A  1  0D 0A 49 6E  INVALID_S19:    .byte      CR,LF,"Invalid S19 record",0
000E9E  1  76 61 6C 69  
000EA2  1  64 20 53 31  
000EAF  1               
000EAF  1  0D 0A 57 61  WAITING:        .byte      CR,LF,"Waiting for XMODEM transfer to start",0
000EB3  1  69 74 69 6E  
000EB7  1  67 20 66 6F  
000ED6  1  0D 0A 54 69  TIMEOUT:        .byte      CR,LF,"Timeout",0
000EDA  1  6D 65 6F 75  
000EDE  1  74 00        
000EE0  1               
000EE0  1  0D 0A 42 20  HELP:           .byte      CR,LF,"B bb           - Set memory bank"
000EE4  1  62 62 20 20  
000EE8  1  20 20 20 20  
000F02  1  0D 0A 44 20                  .byte      CR,LF,"D ssss eeee    - Disassemble memory in current bank"
000F06  1  73 73 73 73  
000F0A  1  20 65 65 65  
000F37  1  0D 0A 45 20                  .byte      CR,LF,"E              - Erase ROM area"
000F3B  1  20 20 20 20  
000F3F  1  20 20 20 20  
000F58  1                               .ifdef   W65C265SXB
000F58  1                               .byte      CR,LF,"F 0-1          - Disable/Enable WDC ROM"
000F58  1                               .byte      CR,LF,"H              - Hunt for RAM"
000F58  1                               .endif
000F58  1  0D 0A 47 20                  .byte      CR,LF,"G [xxxx]       - Run from bb:xxxx or invoke reset vector"
000F5C  1  5B 78 78 78  
000F60  1  78 5D 20 20  
000F92  1  0D 0A 4D 20                  .byte      CR,LF,"M ssss eeee    - Display memory in current bank"
000F96  1  73 73 73 73  
000F9A  1  20 65 65 65  
000FC3  1  0D 0A 52 20                  .byte      CR,LF,"R 0-3          - Select ROM bank 0-3"
000FC7  1  30 2D 33 20  
000FCB  1  20 20 20 20  
000FE9  1  0D 0A 53 2E                  .byte      CR,LF,"S...           - Process S19 record"
000FED  1  2E 2E 20 20  
000FF1  1  20 20 20 20  
00100E  1  0D 0A 57 20                  .byte      CR,LF,"W xxxx yy      - Set memory at xxxx to yy"
001012  1  78 78 78 78  
001016  1  20 79 79 20  
001039  1  0D 0A 58 20                  .byte      CR,LF,"X xxxx         - XMODEM receive to bb:xxxx"
00103D  1  78 78 78 78  
001041  1  20 20 20 20  
001065  1  00                           .byte      0
001066  1               
001066  1                               .end
